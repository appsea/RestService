{
  "questions": [
    {
      "number": "1",
      "description": "The following SAS program is submitted:\n\nData sasuser.history;\nSet sasuser.history(keep=state x y\nRename = (state=ST));\nTotal=sum(x, y);\nRun;\n\nThe SAS data set SASUSER.HISTORY has an index on the variable STATE.\nWhich describes the result of submitting the SAS program?",
      "explanation": "The index does not delete just because the variable associated with it has a change in name from State to ST. Because it's not deleted, it's not 're-created' either, simply updated.\n",
      "options": [
        {
          "tag": "A",
          "description": "A. The index on STATE is deleted and an index on ST is created",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. The index on STATE is recreated as an index on ST",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. The index on STATE is deleted",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. The index on STATE is updated as an index on ST",
          "correct": true
        }
      ]
    },
    {
      "number": "2",
      "description": "The following SAS program is submitted:\n\n%macro one (input);\n%two;\n%put the value is &date;\n%mend;\n%macro two;\ndata _null_;\ncall symput('date','12SEP2008');\nrun;\n%mend;\n%let date=31DEC2006;\n%one(&date)\n\nWhat is the result when the %PUT statement executes?",
      "explanation": "Since the macro-variable DATE is defined as a global variable, it should be in the global symbol table & its value is updated through the macros\nthe %let statement near end of code triggers first, generating a global macro variable. Macro two later changes the value of the macro variable, but it remains global.",
      "options": [
        {
          "tag": "A",
          "description": "A. A macro variable DATE with the value 12SEP2008 is retrieved from the local symbol table for the ONE macro",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. A macro variable DATE with the value 12SEP2008 is retrieved from the local symbol table for the TWO macro",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. A macro variable DATE with the value 12SEP2008 is retrieved from the global symbol table",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. A macro variable DATE with the value 31DEC2006 is retrieved from the global symbol table",
          "correct": false
        }
      ]
    },
    {
      "number": "3",
      "description": "Which SET statements option names a variable that contains the number of the observation to read during the current iteration of the DATA step?",
      "explanation": "The point options points to the current iteration. Also, it needs to be accompanied by STOP keyword. 'A' simply tells how many observations to process. 'D' transfers number of non-missing in dataset to a variable. 'C' is completely irrelevant.",
      "options": [
        {
          "tag": "A",
          "description": "A. OBS=pointobs",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. POINT=pointobs",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. KEY=pointobs",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. NOBS=pointobs",
          "correct": false
        }
      ]
    },
    {
      "number": "4",
      "description": "When reading a SAS data file, what does the NOBS=option on the SET statement represent?",
      "explanation": "it gives the number of observations of the data set which is being read",
      "options": [
        {
          "tag": "A",
          "description": "A. A variable that represents the total number of observation in the output data set(s)",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. A variable that represents a flag indicating the end of the file",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. A variable that represents the total number of observations in the input data set(s)",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. A variable that represents the current observation number",
          "correct": false
        }
      ]
    },
    {
      "number": "5",
      "description": "CORRECT TEXT\nThe following SAS program is submitted:\n\n%macro check(num=4);\n%let result=%sysevalf(&num+0.5);\n%put result is &result;\n%mend;\n%check(num=10)\n\nWhat is the written to the SAS log?",
      "explanation": "the value will be 10.5, since %sysevalf handles floating values. Had we used %eval in its place, the program would fail & the macros execution will stop",
      "options": [
        {
          "tag": "A",
          "description": "A. result is",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. result is 10",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. result is 10.5",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. result is 10+0.5",
          "correct": false
        }
      ]
    },
    {
      "number": "6",
      "description": "The following SAS program is submitted:\n\n%micro test(var);\n%let jobs=BLACKSMITH WORDSMITH SWORDSMITH;\n%let type=%index(&jobs, &var);\n%put type = &type;\n%mend;\n%test(SMITH)\n\nWhat is the value of the macro variable TYPE when the %PUT statement executes?",
      "explanation": "SMITH starts with 6th character of &jobs string.",
      "options": [
        {
          "tag": "A",
          "description": "A. 0",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. Null",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. 6",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. 3",
          "correct": false
        }
      ]
    },
    {
      "number": "7",
      "description": "The following SAS program is submitted:\n\n%macro check(num=4);\n%let result=%eval(&nm gt 5);\n%put result is &result;\n%mend;\n%check (num=10)\n\nWhat is written to the SAS log?",
      "explanation": "%eval returns 0 or 1 for a Boolean expression being calculated inside it. As '1'=true for 10>5, but 1st macro line should be &num, not &nm.",
      "options": [
        {
          "tag": "A",
          "description": "A. result is true",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. result is 10 gt 5",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. result is 1",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. result is 0",
          "correct": false
        }
      ]
    },
    {
      "number": "8",
      "description": "The following SAS program is submitted:\n\n#data temp;\nlength 1 b 3 x;\ninfile 'file reference';\ninput a b x;\nrun;\n\nWhat is the result?",
      "explanation": "D for x having length of 8.",
      "options": [
        {
          "tag": "A",
          "description": "A. The data set TEMP is not created because variables A and B have invalid lengths",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. The data set TEMP is created, but variable X is not created",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. The data set TEMP is not created because variable A has an invalid length",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. The data set TEMP is created and variable X has a length of 8",
          "correct": true
        }
      ]
    },
    {
      "number": "9",
      "description": "Given the SAS data sets ONE and TWO:\n\nONE\nYEAR    QTR     BUDGET\n2001            500\n2001            400\n2003            350\n\nTWO\nYEAR    QTR     BUDGET\n2001    4       300\n2002    1       600\n\nThe following SAS program is submitted:\n\nProc sql;\nSelect two.*,budget from one <insert JOIN operator here> two on one.year=two.year,\nQuit;\n\nFollowing is desired output:\nYEAR    QTR     BUDGET  SALES\n2001    4       300     500\n2001    4       300     400\n2003    1       600     350\n\nWhich JOIN operator completes the program and generates the desired output?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. FULL JOIN",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. INNER JOIN",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. LEFT JOIN",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. RIGHT JOIN",
          "correct": true
        }
      ]
    },
    {
      "number": "10",
      "description": "Given the SAS data set SAUSER.HIGWAY:\n\nSTEERING    SEATBELT    SPEED   STATUS      COUNT\nabsent      no          0-29    serious     31\nabsent      no          0-29    not         1419\nabsent      no          30-49   serious     191\nabsent      no          30-49   not         2004\nabsent      no          50+     serious     216\n\nSASUSER.HIGHWAY\nThe following SAS program is submitted:\n%macro highway;\nproc sql nonprint;\n%let numgrp=6;\nselect distinct status into:group1-:group&numgrp from sasuser.highway;\nquit;\n%do i=1 %to &numgrp;\nproc print data =sasuser.highway;\nwhere status =\"&&group&I\";\nrun;\n%end;\n%mend;\n%highway\n\nHow many reports are produced?",
      "explanation": "As many as the macro variables are there, we get the datasets",
      "options": [
        {
          "tag": "A",
          "description": "A. 2",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. 6",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. 0",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. 5",
          "correct": false
        }
      ]
    },
    {
      "number": "11",
      "description": "The following SAS program is submitted:\n\n%let dept=prod;\n%let prod=merchandise;\n\nThe following message is written to the SAS log:\nThe value is \"merchandise\"\nWhich SAS System option writes this message to the SAS log?",
      "explanation": "%quote doesn't print the quote i.e. \", whereas \"&&&prod\" resolves to \"&merchandise\" with a warning message \"WARNING: Apparent symbolic reference MERCHANDISE not resolved.\". First two '&' sign resolves to a single '&' where as value of &dept is prod so the expression becomes &prod which is merchandise and the \" is printed as it is.",
      "options": [
        {
          "tag": "A",
          "description": "A. %put The value is \"&&&dept\";",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. %put The value is \"&&&prod\";",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. %put The value is %quote (&&&prod);",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. %put The value is %quote (&&&dept);",
          "correct": false
        }
      ]
    },
    {
      "number": "12",
      "description": "The SAS data set WORK.TEMPDATA contains the variables FMTNAME, START and\nLABEL and it consists of 10 observations.\nThe following SAS program is submitted:\n\nProc format cntlin=wor.tempdata;\nRun;\n\nWhat is the result of submitting the FORMAT procedure step?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. It uses the WORK.TEMPDATA SAS data set as input to create the format",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. All formats created will be stored in two WORK.TEMPDATA SAS data set",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. An ERROR message is written to the SAS log because the program is incomplete",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. NO formats are created in this step",
          "correct": false
        }
      ]
    },
    {
      "number": "13",
      "description": "The following SAS program is submitted:\n\ndate view=sasuser.ranch;\ndescribe;\nrun;\n\nWhat is the result?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. The program creates a DATA step view called SASUSER.RANCH and places the program cod in the current editor window",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. The program retrieves the SAS source code that creates the view and places it in the output window",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. The program creates a DATA step view called SASUSER.RANCH and places it in the SAS log",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. the program retrieves the SAS source code that creates the view and places it in the SAS log",
          "correct": true
        }
      ]
    },
    {
      "number": "14",
      "description": "Which SAS procedure changes the name of a permanent format for a variable stored in a\nSAS data set?",
      "explanation": "Proc Datasets is used to perform operations on a data set, like changing the dataset name, indexes,arrtibutes etc.",
      "options": [
        {
          "tag": "A",
          "description": "A. DATASETS",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. MODIFY",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. FORMAT",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. REGISTRY",
          "correct": false
        }
      ]
    },
    {
      "number": "15",
      "description": "Given the SAS data set ONE:\nONE\nDIVISION SALES\nA 1234\nA 3654\nB 5678\nThe following SAS program is submitted:\n\nData_null_;\nSet one;\nBy divition;\nIf first.division then\nDo;\n%let mfirst=sales;\nend;\nrun;\n\nWhat is the value of the macro variable MFRIST when the program finishes execution?",
      "explanation": "Since there is no ampersand sign before sales,when it is being assigned to mfirst, the value of mfirst will be 'sales'",
      "options": [
        {
          "tag": "A",
          "description": "A. 1234",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. sales",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. 5678",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. null",
          "correct": false
        }
      ]
    },
    {
      "number": "16",
      "description": "Which SET statement option names a variable that contains the number of observation to read during the current iteration of the DATA step?",
      "explanation": "POINT specifies whether SAS creates compressed data sets whose observations can be randomly accessed or sequentially accessed.",
      "options": [
        {
          "tag": "A",
          "description": "A. NOBS=pointobs",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. OBS=pointobs",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. KEY=pointobs",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. POINT=pointobs",
          "correct": true
        }
      ]
    },
    {
      "number": "17",
      "description": "The following SAS program is submitted:\n\n%macro check(num=4);\n%let result=%sysevalf(&num+0.5);\n%put result is &result;\n%mend;\n%check(num=10)\n\nWhat is the written to the SAS log?",
      "explanation": "%sysevalf evaluates arithmetic and logical expressions using floating-point arithmetic. Notice the %check call which overwrites the num value to 10.",
      "options": [
        {
          "tag": "A",
          "description": "A. result is",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. result is 10.5",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. result is 10+0.5",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. result is 10",
          "correct": false
        }
      ]
    },
    {
      "number": "18",
      "description": "The following SAS program is submitted:\n\n%let first=yourname;\n%let last=first;\n%put &&&last;\n\nWhat is written to the SAS Log?",
      "explanation": "First two '&' sign resolves to a single '&' where as value of &last is first so the expression becomes &first which is Yourname.",
      "options": [
        {
          "tag": "A",
          "description": "A. First",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. Yourname",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. &&First",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. &yourname",
          "correct": false
        }
      ]
    },
    {
      "number": "19",
      "description": "The following SAS program is submitted:\n\n%let a=cat;\n%macro animal(a=frog);\n%let a=bird;\n%mend;\n%animal(a=pig)\n%put a is &a;\n\nWhat is written to the SAS log?",
      "explanation": "Initially a is set as cat as Global value. The macro definition sets a to bird only within macro definition. When a is called after macro definition, SAS gives Global value of a which is cat.",
      "options": [
        {
          "tag": "A",
          "description": "A. a is pig",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. a is cat",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. a is frog",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. a is bird",
          "correct": false
        }
      ]
    },
    {
      "number": "20",
      "description": "Which SQL procedure program deletes rows from the data set CLASS?",
      "explanation": "Alter command is used to modify table structure so Delete from tablename where condition is correct syntax.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nSelect * from class\nWhere age<(select stop_age from threshold);\nQuit;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nModify table class\nDelete where age<(select stop_age from threshold);\nQuit",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nDelete from class\nWhere age<(select stop_age from threshold);\nQuit;",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nAlter from class\nDelete where age<(select stop_age from threshold);\nQuit;",
          "correct": false
        }
      ]
    },
    {
      "number": "21",
      "description": "The following SAS program is submitted:\n\n%let lib=%upcase(sauser);\nproc sql;\nselect nvar form dictionary.tables where libname='&lib\";\nquit;\n\nSeveral SAS data sets exist in the SAUSER library.\nWhat is generated as output?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. A report showing the names of the columns in each table in SASUSER",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. A report showing the number of columns in each table in SASUSER",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. A report showing the numeric columns in each table in SASUSER",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. A report showing the number of numeric columns in each table in SASUSER",
          "correct": false
        }
      ]
    },
    {
      "number": "22",
      "description": "Given the SAS data sets ONE and TWO:\n\nONE\nID               NAME\n112             Smith\n243             Wei\n457             Jones\n\nTWO\nID               SALARY\n213             150000\n355             45000\n523             75000\n\nThe following SAS program is submitted:\n\nData combine;\nMerge one two;\nBy id;\nRun;\n\nWhich SQL procedure program procedures the same results?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nCreate table combine as\nSelect coalesce (one.id, two.id) as id,\nName,salary from one, two where one.id=two.id;\nQuit;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nCreate table combine as\nSelect one.id,\nName, salary from one full join two where one.id=two.id;\nQuit",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nCreate table combine as\nSelect one.id,name,salary from one inner join two on one.id=two.id\nQuit",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nCreate table combine as\nSelect coalesce (one id, two id) as id,\nName,salary from one full join two on one.id=two.id;\nQuit;",
          "correct": true
        }
      ]
    },
    {
      "number": "23",
      "description": "The following SAS program is submitted:\n\n%let first=yourname;\n%lest last=first\n%put &&last;\n\nWhat is written to the SAS log?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. First",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. &yourname",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. &&First",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. Yourname",
          "correct": true
        }
      ]
    },
    {
      "number": "24",
      "description": "The following SAS program is submitted:\n\nproc contents data = testdata.one;\nrun;\n\nWhich SQL procedure program produces similar information about the column attributes of the dataset TESTDATA.ONE?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nContents table testdata.one;\nQuit;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nDescribe table testdata.one;\nQuit;",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. proc sql;\ndescribe testdata.one;\nQuit;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nContents testdata.one;\nQuit;",
          "correct": false
        }
      ]
    },
    {
      "number": "25",
      "description": "The following SAS program is submitted:\n\ndata temp;\narray points{2,3} (10,15,20,25,30,35);\nrun;\n\nWhat impact does the ARRAY statement have in the Program Data Vector(PDV)?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. No variable are created in the PDV",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. The variables named POINTS10, POINTS15, POINTS20,POINTS25,POINTS30,\nPOINTS35 are created in the PDV",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. The variables named POINTS1, POINTS2, POINTS3 POINTS4, POINTS5,\nPOINTS6 are created in the PDV",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. The variables named POINTS11, POINTS12, POINTS21, POINTS22, POINTS23 are\ncreated in the PDV",
          "correct": false
        }
      ]
    },
    {
      "number": "26",
      "description": "The following SAS program is submitted:\n\n%let a =cat;\n%macro animal(a=frog);\n%let a = bird;\n%mend;\n%animal(a=ping);\n%put a is &a;\n\nWhat is written to the SAS log?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. a is bird",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. a is frog",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. a is cat",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. a is pig",
          "correct": false
        }
      ]
    },
    {
      "number": "27",
      "description": "Given the SAS data set ONE:\nONE\nA Composite Solution With Just One Click - Certification Guaranteed 14\nNUM VAR\n1 A\n2 B\n3 C\n\nWhich SQL procedure program deletes the data set ONE?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nDrop table one;\nQuit;",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nRemove table one;\nQuit;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nDelete table one;\nQuit;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nDelete from one;\nQuit;",
          "correct": false
        }
      ]
    },
    {
      "number": "28",
      "description": "The following SAS program is submitted:\n\n%macro location;\ndata _null_;\ncall symput ('dept','sales');\nrun;\n%let country=Germany;\n%put_global_;\n%mend;\n%let company = ABC;\n%location;\n\nWhich macro variables are written to the SAS log?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. COMPANY and DEPT only",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. COMPANY,COUNTRY and DEPT",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. COMPANY Only",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. COMPANY and COUNTRY only",
          "correct": false
        }
      ]
    },
    {
      "number": "29",
      "description": "What is the purpose of the SASFILE statement?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. It requests that SAS data set be opened and loaded into SAS memory one page at a\ntime",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. It requests that a SAS data set the opened and loaded into SAS memory one variable at\na time",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. It requests that a SAS data set be opened and loaded into SAS memory one\nobservation at a time",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. It requests that a SAS data set be opened and loaded into SAS memory in its entirety",
          "correct": true
        }
      ]
    },
    {
      "number": "30",
      "description": "Given the SAS date sets CLASS1 and CLASS2\nCLASS1 CLASS2\nNAME COURSE NAME COURSE\nLauren MATH1 Smith MATH2\nPatel MATH1 Farmer MATH2\nChang MATH1 Patel MATH2\nChang MATH3 Hiller MATH2\n\nThe following SAS program is submitted:\n\nProc sql;\nSelect name from CLASS1\n<insert SQL set operator here>\nselect name from CLASS;\nquit;\n\nThe following output is desired\nNAME\nChang\nChang\nLauren\n\nWhich SQL set operator completes the program and generates the desired output?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. UNION ALL",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. EXCEPT ALL",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. INTERSECT ALL",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. OUTER UNION ALL",
          "correct": false
        }
      ]
    },
    {
      "number": "31",
      "description": "The following SAS program is submitted:\n\ndata new (bufnp=4);\nset old(bufno=4);\nrun;\n\nWhy are the BUFNO options used?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. To reduce the number I/O operations",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. To reduce network traffic",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. To reduce memory usage",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. To reduce the amount of data read",
          "correct": false
        }
      ]
    },
    {
      "number": "32",
      "description": "The following SAS program is submitted:\noptions reuse=YES;\ndata sasuser RealEstate(compress=CHAR);\nset sasuser houses;\nrun;\n\nWhat is the effect of the REUSE=YES SAS system option?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. It tracks and recycles free space",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. It allows a permanently stored SAS data set to be replaced",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. It allows users to access the same SAS data set concurrently",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. It allows updates in place",
          "correct": false
        }
      ]
    },
    {
      "number": "33",
      "description": "The SAS data set ONE contains fifty million observations and contains the variable\nPRICE, QUANTITY, FIXED and VARIABLE. Which SAS program successfully creates\nthree new variables TOTREV, TOTCOST and PROFIT and requires the least amount of\nCPU resources to be processed?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. data two;\nSet one;\nWhere totrev>1000;\nTotrev=sum(price*quantity);\nTotcost=sum(fixed,variable);\nProfit=sum(totrev,-totcost);\nRun;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. data two;\nSet one;\ntotrev=sum(price*quantity);\nwhere totrev>1000;\ntotcost=sum(fixed,variable);\nprofit=sum(totrev,-totcost);\nrun;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. data two;\nSet one;\nTotrev=sum(price*quantity);\nIf totrev>1000;\nTotcost=sum(fixed,variable);\nProfit=sum(totrev,-totcost);\nRun;",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. data two;\nSet one;\nTotrev = sum(price*quantity);\nTotcost= sum(fixed,variable);\nIf totrev>1000;\nProfit=sum(totrev,-totcost);\nRun;",
          "correct": false
        }
      ]
    },
    {
      "number": "34",
      "description": "The following SAS program is submitted:\n\n%macro location;\ndata _null_;\ncall symput ('dept','sales');\nrun;\n%let country=Germany;\n%put_global_;\n%mend;\n%let company = ABC;\n%location;\n\nWhich macro variables are written to the SAS log?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. COMPANY and COUNTRY only",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. COMPANY Only",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. COMPANY and DEPT only",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. COMPANY,COUNTRY and DEPT",
          "correct": false
        }
      ]
    },
    {
      "number": "35",
      "description": "The following SAS program is submitted:\n\ndata temp;\nset sasuser.history(kep=date);\nformat date qtr\n<insert BY statement here>\nif first.date then total=0;\ntotal+1;\nif last.date;\nrun;\nproc print data=temp;\nrun\n\nSASUSER.HISTORY is sorted by the SAS date variable DATE.\nThe following output is required:\nDate Total\n1 13\n3 15\n4 25\n\nWhich By statement completes the data step and successfully generates the required output?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. by groupformat date;",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. by formateed date;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. by notsorted date;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. by date qtr",
          "correct": false
        }
      ]
    },
    {
      "number": "36",
      "description": "Which statement(s) in the DATASETS procedure alter(s) the name of a SAS data set stored in a SAS data library?",
      "explanation": "The CHANGE Statement Renames one or more SAS files in the same SAS library.",
      "options": [
        {
          "tag": "A",
          "description": "A. MODIFY and CHANGE statements",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. RENAME statement only",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. CHANGE statement only",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. MODIFY and RENAME statements",
          "correct": false
        }
      ]
    },
    {
      "number": "37",
      "description": "Given has SAS dataset ONE:\nONE\nNAME    SALARY\nHans    200\nMaria   205\nJose    310\nAriel   523\n\nThe following SAS program is submitted:\n\nProc sql;\n<insert SQL clause here>\nfrom one;\nquit;\n\nThe following output is desired:\nSALARY      BONUS\n200         20\n205         20.5\n310         31\n523         52.3\n\nWhich SQL procedure clause completes the program and generates the desired output?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. Select salary, salary*.10 var=BONUS",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. Select salary, salary*.10 label='BONUS'",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. Select salary, salary *.10 column='BONUS'",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. Select salary, salary*.10 name='BONUS'",
          "correct": false
        }
      ]
    },
    {
      "number": "38",
      "description": "The SAS data set WORK.TEMPDATA contains the variable FMTNAME, START and\nLABEL and it consists of 10 observations.\nThe following SAS program is submitted:\nproc format cntlin=work.tempdata;\nrun;\nWhat is the result of submitting the FORMAT procedure step?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. No formats are created in this step",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. All formats created will be stored in the WORK.TEMPDATA SAS set",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. An ERROR message is written to the SAS log because the program is incomplete",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. It uses the WORK.TEMPDATA SAS data set as input to create the format",
          "correct": true
        }
      ]
    },
    {
      "number": "39",
      "description": "Given the non-indexed SAS data set TEMP:\nTEMP\nX Y\n- -\nP 52\nP 45\nA 13\nA 56\nR 34\nR 12\nR 78\n\nThe following SAS program is submitted:\n\nProc print data=temp;\n<insert BY statement here>\nrun;\n\nWhich BY statement completes the program, creates a listing report that is grouped by X and completes without errors?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. By X notsorted;",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. By X grouped;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. By Descending X;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. By X;",
          "correct": false
        }
      ]
    },
    {
      "number": "40",
      "description": "The following SAS program is submitted:\n\n%micro test(var);\n%let jobs=BLACKSMITH WORDSMITH SWORDSMITH;\n%let type=%index(&jobs,&var);\n%put type = &type;\n%mend;\n%test(SMITH)\n\nWhat is the value of the macro variable TYPE when the %PUT statement executes?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. 3",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. Null",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. 6",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. 0",
          "correct": false
        }
      ]
    },
    {
      "number": "41",
      "description": "Given the data set SASHELP.CLASS\n\nSASHELP.CLASS\nNAME AGE\nMary 15\nPhilip 16\nRobert 12\nRonald 15\n\nThe following SAS program is submitted\n\n%let value = Philip;\nproc print data =sashelp.class;\n<insert Where statement here>\nrun;\n\nWhich WHERE statement successfully completes the program and produces a report?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. Where upcase(name)=\"upcase(&value)\";",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. Where upcase(name)=\"%upcase(&value)\";",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. Where upcase(name)=upcase(&value);",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. Where upcase(name)=%upcase(&value);",
          "correct": false
        }
      ]
    },
    {
      "number": "42",
      "description": "Following SAS program is submitted:\n\ndata temp(<insert option here>);\ninfile 'rawdata';\ninput x $ y z;\nrun;\n\nRAWDATA is a file reference to an external file that is ordered by the variable X.\nWhich option specifies how the data in the SAS data set TEMP will be sorted?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. ORDEREDBY=X",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. GROUPBY=X",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. SORTEDBY=X",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. SORTSYNC=X",
          "correct": false
        }
      ]
    },
    {
      "number": "43",
      "description": "Given the following partial SAS log:\nNOTE: SQL table SASHELP.CLASS was created line\nCreate table SASHELP.CLASS(bufsize=4096)\n(\nName char(8);\nGender Char(1);\nAge num;\nHeight num;\nWeight num\n);\n\nWhich SQL procedure statement generated this output?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. DESCRIBE TABLE",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. LIST TABLE",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. VALIDATE TABLE",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. CREATE TABLE",
          "correct": false
        }
      ]
    },
    {
      "number": "44",
      "description": "The following SAS program is submitted:\n\noptions mprint;\n%macro test(parm);\nproc &parm data = sashelp.prdsale;\nrun;\n%mend;\n%test(print)\n\nWhat is the result of the MPRINT options?",
      "explanation": "In this query\nSMITH 200 + SMITH 400 + SMITH 600 + SMITH 800\n\nAverage for SMITH = 2000/4 = 500\n\nJONES 100 + JONES 100 + JONES 200 + JONES 400 + JONES 100 + JONES 300\nAverage for JONES = 1200/6 = 200\n\nNow query select avg(cost) from one will select the first record which would be 200 (Average of JONES)\nNow statement avg(cost) > (select avg(cost) from one) will return Average of SMITH 500, because it is >200",
      "options": [
        {
          "tag": "A",
          "description": "A. It has no effect in this example",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. It writes the original program code inside the marco definition to the SAS log",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. It writes macro execution messages to the SAS.log",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. It echoes the text sent to the SAS compiler as a result of macro execution in the SAS log",
          "correct": true
        }
      ]
    },
    {
      "number": "45",
      "description": "Which one of the following options controls the pagesize of a SAS data set?",
      "explanation": "BUFSIZE= Data Set Option\nSpecifies the size of a permanent buffer page for an output SAS data set.\nValid in: DATA step and PROC steps\nCategory: Data Set Control\nRestriction: Use with output data sets only.",
      "options": [
        {
          "tag": "A",
          "description": "A. SIZE=",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. BUFNO=",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. BUFSIZE=",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. PAGESIZE=",
          "correct": false
        }
      ]
    },
    {
      "number": "46",
      "description": "The following SAS program is submitted:\n\n(insert statement here)\n%let development = ontime;\n\nproc print data = sasuser.highway;\ntitle For &;\ntitle2 This project was completed &development;\nrun;\n\nWhich one of the following statements completes the above and resolves titlel to For research&amp;development?",
      "explanation": "%STR and %NRSTR Functions Mask special characters and mnemonic operators in constant text at macro compilation.\n\nIf a special character or mnemonic affects the way the macro processor constructs macro program statements, you must mask the item during macro compilation (or during the compilation of a macro program statement in open code) by using either the %STR or %NRSTR macro quoting functions.",
      "options": [
        {
          "tag": "A",
          "description": "A. %let dept = %str(research&development);",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B.  %let dept = %str(research%&development);",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. %let dept = %nrstr(research&development);",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. %let dept = %nrstr(research%&development);",
          "correct": false
        }
      ]
    },
    {
      "number": "47",
      "description": "The following SAS program is submitted:\n\nproc sort data = sales tagsort;\nby month year;\nrun;\n\nWhich of the following resource(s) is the TAGSORT option reducing?",
      "explanation": "TAGSORT stores only the BY variables and the observation numbers in temporary files. The BY variables and the observation numbers are called tags. At the completion of the sorting process, PROC SORT uses the tags to retrieve records from the input data set in sorted order.",
      "options": [
        {
          "tag": "A",
          "description": "A. I/O usage only",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. CPU usage only",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. I/O and CPU usage",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. temporary disk usage",
          "correct": true
        }
      ]
    },
    {
      "number": "48",
      "description": "The following SAS program is submitted:\n\ndata one;\ndo i = ito 10;\nptobs = ceil(ranuni(0) * totobs);\nset temp point = ptobs nobs = totobs;\noutput;\nend;\nstop;\nrun;\n\nThe SAS data set TEMP contains 2,500,000 observations. Which one of the following represents the possible values for PTOBS?",
      "explanation": "RANUNI Function Returns a random variate from a uniform distribution. RANUNI(seed) : seed",
      "options": [
        {
          "tag": "A",
          "description": "A.  any integer between 1 and 10",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B.  any real number between 0 and 1",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C.  any integer between 1 and 2,500,000",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D.  any real number between 1 and 2,500,000",
          "correct": false
        }
      ]
    },
    {
      "number": "49",
      "description": "Which one of the following programs contains a syntax error?",
      "explanation": "In option C, there are reference to c.unitcost and s.quantity of which c and s are not defined anywhere in the code. If anything refered as a refrence then it has to be first defined.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nselect product.*, cost.unitcost, sales .quantity\nfrom product p, cost c, sales s\nwhere p.item = c.item and p.item = s.item;\nquit;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B.  proc sql;\nselect product.*, cost.unitcost, sales.quantity\nfrom product, cost,\nsales where product.item = cost.item and product.item = sales.item;\nquit;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C.  proc sql;\nselect p.*, c.unitcost, s.quantity\nfrom product as p, cost as c, sales as s\nwhere p.item = c.item and p.item = s.item;\nquit;",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D.  proc sql;\nselect p.*, c.unitcost, s.quantity\nfrom product, cost, sales\nwhere product.item = cost.item and product.item = sales.item;\nquit;",
          "correct": false
        }
      ]
    },
    {
      "number": "50",
      "description": "The following SAS code is submitted:\n\n%macro houses(dsn = houses,sub = RANCH);\ndata &dsn;\nset sasuser.houses; if style = &sub;\nrun;\n%mend;\n\n%houses(sub = SPLIT)\n%houses(dsn = ranch)\n%houses(sub = TWOSTORY)\n\nWhich one of the following is the value of the automatic macro variable SYSLAST?",
      "explanation": "SYSLAST the name of the most recently created SAS data set, in the form LIBREF.NAME. This value is always stored in ALL capital letters. SYSLAST Automatic Macro Variable Contains the name of the SAS data file created most recently.",
      "options": [
        {
          "tag": "A",
          "description": "A. work.ranch",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. work.houses",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. WORK.RANCH",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. WORK.HOUSES",
          "correct": true
        }
      ]
    },
    {
      "number": "51",
      "description": "Given the following SAS data sets ONE and TWO:\nONE\nNUM     COUNTRY\n1       CANADA\n2       FRANCE\n3       GERMANY\n4       BELGIUM\n5       JAPAN\n\nTWO\nNUM     CITY\n3       BERLIN\n5       TOKYO\n\nThe following SAS program is submitted:\n\nproc sql;\nselect country from one\nwhere not exists (select * from two where one.num = two.num);\nquit;\n\nWhich one of the following reports is generated?",
      "explanation": "EXISTS condition Tests if a subquery returns one or more rows.\nThe EXISTS condition is an operator whose right operand is a subquery. The result of an EXISTS condition is true if the subquery resolves to at least one row. The result of a NOT EXISTS condition is true if the subquery evaluates to zero rows.",
      "options": [
        {
          "tag": "A",
          "description": "A. COUNTRY\nGERMANY JAPAN",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. COUNTRY\nFRANCE BELGIUM",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. COUNTRY\nCANADA FRANCE BELGIUM",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. COUNTRY\nCANADA FRANCE GERMANY",
          "correct": false
        }
      ]
    },
    {
      "number": "52",
      "description": "Which one of the following statements is true?",
      "explanation": "WHERE Statement Selects observations from SAS data sets that meet a particular condition.",
      "options": [
        {
          "tag": "A",
          "description": "A. The WHERE statement can be executed conditionally as part of an IF statement.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. The WHERE statement selects observations before they are brought into the PDV.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. The subsetting IF statement works on observations before they are read into the PDV.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. The WHERE and subsetting IF statements can be used interchangeably in all SAS programs.",
          "correct": false
        }
      ]
    },
    {
      "number": "53",
      "description": "Which of the clauses in the PROC SQL program below is written incorrectly?\n\nproc sql;\nselect style sqm kitchen\nfrom choice.houses\nwhere sqm ge 300;",
      "explanation": "The SELECT clause in the program is written incorrectly. Columns that are listed in the clause must be separated by commas, not just blanks.",
      "options": [
        {
          "tag": "A",
          "description": "A.  SELECT",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B.  FROM",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C.  WHERE",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D.  both 1 and 3",
          "correct": false
        }
      ]
    },
    {
      "number": "54",
      "description": "How many statements does the program below contain?\n\nproc sql;\nselect grapes,oranges,\ngrapes + oranges as sumsales\nfrom sales.produce\norder by sumsales;",
      "explanation": "There are two statements, the PROC SQL statement and the SELECT statement. The SELECT statement contains three clauses.",
      "options": [
        {
          "tag": "A",
          "description": "A.  2",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B.  3",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C.  4",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D.  5",
          "correct": false
        }
      ]
    },
    {
      "number": "55",
      "description": "Complete the following PROC SQL query to select the columns Address and SqFeet from the table List.Size\nand to select Price from the table List.Price. (Only the Address column appears in both tables.)\nproc sql;\n_____________\nfrom list.size,list.price;",
      "explanation": "The SELECT clause lists the columns from both tables to be queried. You must use a prefix with the Address column because it appears in both tables. The prefix specifies the table from which you want the column to be read.",
      "options": [
        {
          "tag": "A",
          "description": "A.  select address,sqfeet,price",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B.  select size.address,sqfeet,price",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C.  select price.address,sqfeet,price",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. either 2 or 3",
          "correct": false
        }
      ]
    },
    {
      "number": "56",
      "description": "The variable attributes of SAS data sets ONE and TWO are shown below:\nONE\n# Variable Type Len Pos\n2 sales Num 8 8\n1 year Num 8 0\n\nTWO\n# Variable Type Len Pos\n2 budget Num 8 8\n3 sales Char 8 16\n1 year Num 8 0\nData set ONE contains 100 observations. Data set TWO contains 50 observations. Both data sets are sorted by the variable YEAR. The following SAS program is submitted:\ndata three;\nmerge one two;\nby year;\nrun;\n\nWhich one of the following is the result of the program execution?",
      "explanation": "Any variables that have the same name in multiple data sets in the merge statement must also have the same type. Otherwise error and warning message would come out!",
      "options": [
        {
          "tag": "A",
          "description": "A.  No messages are written to the SAS log.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B.  ERROR and WARNING messages are written to the SAS log.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C.  Data set THREE is created with two variables and 50 observations.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D.  Data set THREE is created with three variables and 100 observations.",
          "correct": false
        }
      ]
    },
    {
      "number": "57",
      "description": "Given the following SAS statement:\n\n%let idcode = Prod567;\n\nWhich one of the following statements stores the value 567 in the macro variable CODENUM?",
      "explanation": "Retrieve the substring from the 5 th position, If you use an undeclared variable, it will be assigned a default length of 8 when the SUBSTR function is compiled.\nWhen you use the SUBSTR function on the left side of an assignment statement, SAS replaces the value of variable with the expression on the right side. SUBSTR replaces length characters starting at the character that you specify in position.",
      "options": [
        {
          "tag": "A",
          "description": "A.  %let codenum = substr(&amp;idcode,length(&amp;idcode)-2);",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B.  %let codenum = substr(&amp;idcode,length(&amp;idcode)-3);",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C.  %let codenum = %substr(&amp;idcode,%length(&amp;idcode)-2);",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D.  %let codenum = %substr(&amp;idcode,%length(&amp;idcode)-3);",
          "correct": false
        }
      ]
    },
    {
      "number": "58",
      "description": "The following SAS program is submitted:\n\ndata new (bufsize = 6144 bufno = 4);\nset old;\nrun;\n\nWhich one of the following describes the difference between the usage of BUFSIZE= and BUFNO= options?",
      "explanation": "BUFSIZE= Data Set Option\nSpecifies the size of a permanent buffer page for an output SAS data set.\nThe page size is the amount of data that can be transferred for a single I/O operation to one buffer. The page size is a permanent attribute of the data set and is used when the data set is processed.",
      "options": [
        {
          "tag": "A",
          "description": "A. BUFSIZE= specifies the size of the input buffer in bytes; BUFNO= specifies the number of input buffers.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. BUFSIZE= specifies the size of the output buffer in bytes; BUFNO= specifies the number of output buffers.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. BUFSIZE= specifies the size of the output buffer in kilobytes; BUFNO= specifies the number of input buffers.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. BUFSIZE= specifies the size of the output buffer in kilobytes; BUFNO= specifies the number of output buffers.",
          "correct": false
        }
      ]
    },
    {
      "number": "59",
      "description": "If you specify a CREATE TABLE statement in your PROC SQL step,",
      "explanation": "Create Table simply creates the table.",
      "options": [
        {
          "tag": "A",
          "description": "A. The results of the query are displayed, and a new table is created.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. A new table is created, but it does not contain any summarization that was specified in the PROC SQL step.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. A new table is created, but no report is displayed.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. Results are grouped by the value of the summarized column.",
          "correct": false
        }
      ]
    },
    {
      "number": "60",
      "description": "Consider the following SAS log:\n229 data sasuser.ranch sasuser.condo / view = sasuser.ranch;\n230 set sasuser.houses;\n231 if style = RANCH then output sasuser.ranch;\n232 else if style = CONDO then output sasuser.condo;\n233 run;\nNOTE: DATA STEP view saved on file SASUSER.RANCH.\nNOTE: A stored DATA STEP view cannot run under a different operating system.\n235 proc print data = sasuser.condo;\nERROR: File SASUSER.CONDO.DATA does not exist.\n236 run;\nNOTE: The SAS System stopped processing this step because of errors.\n\nWhich one of the following explains why the PRINT procedure fails ?",
      "explanation": "A data step view contains a partially compiled data step program that can read data from a variety of source\nThe compiled code doesnt take up too much room for storage\nthe view= option tells sas to compile, but not to execute, the source program and to store the compiled code in the input data step that is named in the option",
      "options": [
        {
          "tag": "A",
          "description": "A. nbsp; nbsp; SASUSER.CONDO is a stored DATA step program.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. nbsp; nbsp; A SAS data file and SAS data view cannot be created in the same DATA step.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. nbsp; nbsp; A second VIEW=SASUSER.CONDO option was omitted on the DATA statement.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. nbsp; nbsp; The view SASUSER.RANCH must be processed before SASUSER.CONDO is created.",
          "correct": true
        }
      ]
    },
    {
      "number": "61",
      "description": "Which PROC SQL query will remove duplicate values of MemberType from the query output, so that only the unique values are listed?",
      "explanation": "To remove duplicate values from PROC SQL output, you specify the DISTINCT keyword before the column name in the SELECT clause.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql nodup;\nselect membertype\nfrom sasuser.frequentflyers;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nselect distinct(membertype)\nas MemberType\nfrom sasuser.frequentflyers;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nselect unique membertype\nfrom sasuser.frequentflyers\ngroup by membertype;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nselect distinct membertype\nfrom sasuser.frequentflyers;",
          "correct": true
        }
      ]
    },
    {
      "number": "62",
      "description": "Which of the clauses in the PROC SQL program below is written incorrectly?\n\nproc sql;\nselect style sqfeet bedrooms\nfrom choice.houses\nwhere sqfeet ge 800;",
      "explanation": "The SELECT clause in the program is written incorrectly. Columns that are listed in the clause must be separated by commas, not just blanks.",
      "options": [
        {
          "tag": "A",
          "description": "A. SELECT",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. FROM",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. WHERE",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. both a and c",
          "correct": false
        }
      ]
    },
    {
      "number": "63",
      "description": "How many statements does the program below contain?\n\nproc sql;\nselect grapes,oranges,\ngrapes + oranges as sumsales\nfrom sales.produce\norder by sumsales;",
      "explanation": "There are two statements, the PROC SQL statement and the SELECT statement. The SELECT statement contains three clauses.\n",
      "options": [
        {
          "tag": "A",
          "description": "A. two",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. three",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. four",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. five",
          "correct": false
        }
      ]
    },
    {
      "number": "64",
      "description": "Complete the following PROC SQL query to select the columns Address and SqFeet from the table List.Size and to select Price from the table List.Price. (Only the Address column appears in both tables.)\nproc sql;\n_____________\nwhere size.address = price.address;\nfrom list.size,list.price;",
      "explanation": "The SELECT clause lists the columns from both tables to be queried. You must use a prefix with the Address column because it appears in both tables. The prefix specifies the table from which you want the column to be read.",
      "options": [
        {
          "tag": "A",
          "description": "A. select address,sqfeet,price",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. select size.address,sqfeet,price",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. select price.address,sqfeet,price",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. either b or c",
          "correct": false
        }
      ]
    },
    {
      "number": "65",
      "description": "Which of the clauses below correctly sorts rows by the values of the columns Price and SqFeet?",
      "explanation": "The ORDER BY clause specifies how the rows are to be sorted. You follow the keywords ORDER BY by one or more column names or numbers, separated by commas.",
      "options": [
        {
          "tag": "A",
          "description": "A. order price, sqfeet",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. order by price,sqfeet",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. sort by price sqfeet",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. sort price sqfeet",
          "correct": false
        }
      ]
    },
    {
      "number": "66",
      "description": "Which clause below specifies that the two tables Produce and Hardware be queried? Both tables are located in a library to which the libref Sales has been assigned.",
      "explanation": "In the FROM clause, you list the names of the tables to be queried, separated by commas.",
      "options": [
        {
          "tag": "A",
          "description": "A. select sales.produce sales.hardware",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. from sales.produce sales.hardware",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. from sales.produce,sales.hardware",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. where sales.produce, sales.hardware",
          "correct": false
        }
      ]
    },
    {
      "number": "67",
      "description": "Complete the SELECT clause below to create a new column named Profit by subtracting the values of the column Cost from those of the column Price.\nselect fruit,cost,price,\n________________",
      "explanation": "To create a new column and assign a column alias to the column, you specify the following in the SELECT clause, in the order shown here: an expression, (optionally) the keyword AS, and a column alias. The case that you use when you create the column name is the one that will be displayed in the output.",
      "options": [
        {
          "tag": "A",
          "description": "A. Profit=price-cost",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. price-cost as Profit",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. profit=price-cost",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. Profit as price-cost",
          "correct": false
        }
      ]
    },
    {
      "number": "68",
      "description": "What happens if you use a GROUP BY clause in a PROC SQL step without a summary function?",
      "explanation": "The GROUP BY clause enables you to break query results into subsets of rows. When you use the GROUP BY clause, you use an aggregate function in the SELECT clause or a HAVING clause to  instruct PROC SQL how to group the data. When you specify a GROUP BY clause in a query that does not contain a summary function, your clause is changed to an ORDER BY clause.",
      "options": [
        {
          "tag": "A",
          "description": "A. The step does not execute.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. The first numeric column is summed by default.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. The GROUP BY clause is changed to an ORDER BY clause.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. The step executes but does not group or sort data.",
          "correct": false
        }
      ]
    },
    {
      "number": "69",
      "description": "If you specify a CREATE TABLE statement in your PROC SQL step,",
      "explanation": "The CREATE TABLE statement enables you to store your results in a SAS table instead of displaying the query results as a report.",
      "options": [
        {
          "tag": "A",
          "description": "A. the results of the query are displayed, and a new table is created.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. a new table is created, but it does not contain any summarization that was specified in the PROC SQL step.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. a new table is created, but no report is displayed.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. results are grouped by the value of the summarized column.",
          "correct": false
        }
      ]
    },
    {
      "number": "70",
      "description": "Which statement is true regarding the use of the PROC SQL step to query data that is stored in two or more tables?",
      "explanation": "If you are joining two tables that contain a same-named column, then you must use a prefix to specify the table(s) from which you want the column to be read. Remember that if you join tables that don't contain columns that have matching data values, you can produce a huge amount of output. Be sure to specify a WHERE clause to select only the rows that you want.",
      "options": [
        {
          "tag": "A",
          "description": "A. When you join multiple tables, the tables must contain a common column.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. You must specify the table from which you want each column to be read.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. The tables that are being joined must be from the same type of data source.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. If two tables that are being joined contain a same-named column, then you must specify the table from which you want the column to be read.",
          "correct": true
        }
      ]
    },
    {
      "number": "71",
      "description": "Which clause in the following program is incorrect?\n\nproc sql;\nselect sex,mean(weight) as avgweight\nfrom company.employees company.health\nwhere employees.id=health.id\ngroup by sex;",
      "explanation": "The table names that are specified in the FROM clause must be separated by commas. Note that you can specify columns in the WHERE clause that are not specified in the SELECT clause.",
      "options": [
        {
          "tag": "A",
          "description": "A. SELECT",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. FROM",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. WHERE",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. GROUP BY",
          "correct": false
        }
      ]
    },
    {
      "number": "72",
      "description": "Which PROC SQL query removes duplicate values of MemberType from the query output, so that only the unique values are listed?",
      "explanation": "To remove duplicate values from PROC SQL output, you specify the DISTINCT keyword before the column name in the SELECT clause.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql nodup;\nselect membertype\nfrom sasuser.frequentflyers;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nselect distinct(membertype)\nas MemberType\nfrom sasuser.frequentflyers;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nselect unique membertype\nfrom sasuser.frequentflyers\ngroup by membertype;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nselect distinct membertype\nfrom sasuser.frequentflyers;",
          "correct": true
        }
      ]
    },
    {
      "number": "73",
      "description": "Which of the following causes PROC SQL to list rows that have no data in the Address column?",
      "explanation": "To list rows that have no data (that is, missing data), you can use either of these other conditional operators: IS MISSING or IS NULL. The NOT EXISTS operator is used specifically with a subquery, and resolves to true if the subquery returns no values to the outer query.",
      "options": [
        {
          "tag": "A",
          "description": "A. WHERE address is missing",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. WHERE address not exists",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. WHERE address is null",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. both a and c",
          "correct": true
        }
      ]
    },
    {
      "number": "74",
      "description": "You are creating a PROC SQL query that lists all employees who have spent (or overspent) their allotted 120 hours of vacation for the current year. The hours that each employee used are stored in the existing column Spent. Your query defines a new column, Balance, to calculate each employee's balance of vacation hours.\nWhich query produces the report that you want?",
      "explanation": "When a WHERE clause references a new column that was defined in the SELECT clause, the WHERE clause must specify the keyword CALCULATED before the column name.\n",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nselect name, spent,\n120-spent as calculated Balance\nfrom Company.Absences\nwhere balance <= 0;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nselect name, spent,\n120-spent as Balance\nfrom Company.Absences\nwhere calculated balance <= 0;",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nselect name, spent,\n120-spent as Balance\nfrom Company.Absences\nwhere balance <= 0;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nselect name, spent,\n120-spent as calculated Balance\nfrom Company.Absences\nwhere calculated balance <= 0;",
          "correct": false
        }
      ]
    },
    {
      "number": "75",
      "description": "Consider this PROC SQL query:\n\nproc sql;\nselect flightnumber,\ncount(*) as Flights,\navg(boarded)\nlabel=\"Average Boarded\"\nformat=3.\nfrom sasuser.internationalflights\ngroup by flightnumber\nhaving avg(boarded) > 150;The table Sasuser.Internationalflights contains 201 rows, 7 unique values of FlightNumber, 115 unique values of Boarded, and 4 different flight numbers that have an average value of Boarded that is greater than 150. How many rows of output is generated by the query?",
      "explanation": "To determine how PROC SQL calculates and displays output from summary functions, consider the key factors. This PROC SQL query has a GROUP BY clause, and it does not specify any columns that are outside of summary functions. Therefore, PROC SQL calculates and displays the summary function for each group. There are 7 unique values of FlightNumber, but the HAVING clause specifies only the flights that have an average number of boarded passengers greater than 150. Because 4 of the 7 flight numbers meet this condition, the output will contain 4 rows.",
      "options": [
        {
          "tag": "A",
          "description": "A. 150",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. 7",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. 4",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. 1",
          "correct": false
        }
      ]
    },
    {
      "number": "76",
      "description": "You are writing a PROC SQL query that displays the names of all library cardholders who work as volunteers for the library, and the number of books that each volunteer currently has checked out. You use one or both of the following tables:\nLibrary.Circulation lists the name and contact information for all library cardholders, and the number of books that each cardholder currently has checked out.\nLibrary.Volunteers lists the name and contact information for all library volunteers.Assume that the values of Name are unique in both tables.\nWhich of the following PROC SQL queries produces your report?",
      "explanation": "Your PROC SQL query needs to use data from both tables. The outer query reads the name and number of books checked out from Library.Circulation. The multiple-value noncorrelated subquery selects the names of volunteers from Library.Volunteers and passes these names back to the outer query. The outer query then selects data for only the volunteers whose names match names returned by the subquery. The subquery is indented under the outer query's WHERE clause, is enclosed in parentheses, and does not require a semicolon inside the closing parenthesis.\n",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nselect name, checkedout\nfrom library.circulation\nwhere * in\n(select *\nfrom library.volunteers);",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nselect name, checkedout\nfrom library.circulation\nwhere name in\n(select name\nfrom library.volunteers);",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nselect name\nfrom library.volunteers\nwhere name, checkedout in\n(select name, checkedout\nfrom library.circulation);",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nselect name, checkedout\nfrom library.circulation\nwhere name in\n(select name\nfrom library.volunteers;);",
          "correct": false
        }
      ]
    },
    {
      "number": "77",
      "description": "By definition, a noncorrelated subquery is a nested query that",
      "explanation": "A noncorrelated subquery is a nested query that executes independently of the outer query. The outer query passes no values to the subquery.",
      "options": [
        {
          "tag": "A",
          "description": "A. returns a single value to the outer query.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. contains at least one summary function.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. executes independently of the outer query.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. requires only a single value to be passed to it by the outer query.",
          "correct": false
        }
      ]
    },
    {
      "number": "78",
      "description": "Which statement about the following PROC SQL query is false?\n\nproc sql;\nvalidate\nselect name label='Country',\nrate label='Literacy Rate'\nfrom world.literacy\nwhere 'Asia' =\n(select continent\nfrom world.continents\nwhere literacy.name =\ncontinents.country)\norder by 2;",
      "explanation": "The syntax in this PROC SQL query is valid, so the first statement is false. The query contains a correlated subquery, so the second statement is true. The VALIDATE keyword is used after the PROC SQL statement, so the third statement is true. And the last statement correctly indicates that the VALIDATE keyword causes the SAS log to display a special message if the query syntax is valid, or standard error messages if the syntax is not valid.",
      "options": [
        {
          "tag": "A",
          "description": "A. The query syntax is not valid.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. The outer query must pass values to the subquery before the subquery can return values to the outer query.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. PROC SQL cannot execute this query when it is submitted.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. After the query is submitted, the SAS log indicates whether the query has valid syntax.",
          "correct": false
        }
      ]
    },
    {
      "number": "79",
      "description": "Consider the following PROC SQL query:\n\nproc sql;\nselect lastname, firstname,\ntotal, since\nfrom charity.donors\nwhere not exists\n(select lastname\nfrom charity.current\nwhere donors.lastname =\ncurrent.lastname);\nThe query references two tables:\nCharity.Donors lists name and contact information for all donors who have made contributions since the charity was founded. The table also contains these two columns: Total, which shows the total dollars given by each donor, and Since, which stores the first year in which each donor gave money.\nCharity.Current lists the names of all donors who have made contributions in the current year, and the total dollars each has given this year (YearTotal).\nAssume that the values of LastName are unique in both tables.\nThe output of this query displays",
      "explanation": "In this PROC SQL query, the outer query uses the operator NOT EXISTS with a correlated subquery. The outer query selects all rows from Charity.Donors whose names do not appear in Charity.Current. In other words, this PROC SQL query output lists all donors who did not make a contribution in the current year.",
      "options": [
        {
          "tag": "A",
          "description": "A. all donors whose rows do not contain any missing values.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. all donors who made a contribution in the current year.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. all donors who did not make a contribution in the current year.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. all donors whose current year's donation in Charity.Current has not yet been added to Total in Charity.Donors.",
          "correct": false
        }
      ]
    },
    {
      "number": "80",
      "description": "Which statement about data remerging is true?",
      "explanation": "The third statement about data remerging is correct.",
      "options": [
        {
          "tag": "A",
          "description": "A. When PROC SQL remerges data, it combines data from two tables.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. By using data remerging, PROC SQL can avoid making two passes through the data.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. When PROC SQL remerges data, it displays a related message in the SAS log.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. PROC SQL does not attempt to remerge data unless a subquery is used.",
          "correct": false
        }
      ]
    },
    {
      "number": "81",
      "description": "A public library has several categories of books. Each book in the library is assigned to only one category. The table Library.Inventory contains one row for each book in the library. The Checkouts column indicates the number of times that each book has been checked out.\nYou want to display only the categories that have an average circulation (number of checkouts) that is less than 2500. Does the following PROC SQL query produce the results that you want?\n\nproc sql;\ntitle 'Categories with Average Circulation';\ntitle2 'Less Than 2500';\nselect category,\navg(checkouts) as AvgCheckouts\nfrom library.inventory\nhaving avg(checkouts) < 2500\norder by 1;",
      "explanation": "PROC SQL can execute this query, but the query will not produce the results that you want. If you omit the GROUP BY clause in a query that contains a HAVING clause, then the HAVING clause and any summary functions treat the entire table as one group. Without a GROUP BY clause, the HAVING clause in this example calculates the average circulation for the table as a whole (all books in the library), not for each group (each category of books). The output contains either all the rows in the table (if the average circulation for the entire table is less than 2500) or none of the rows in the table (if the average circulation for the entire table is greater than 2500).",
      "options": [
        {
          "tag": "A",
          "description": "A. No. This query does not run because a HAVING clause cannot contain a summary function.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. No. This query does not run because the HAVING clause must include the CALCULATED keyword before the summary function.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. No. Because there is no GROUP BY clause, the HAVING clause treats the entire table as one group.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. Yes. Requires only a single value to be passed to it by the outer query.",
          "correct": false
        }
      ]
    },
    {
      "number": "82",
      "description": "A Cartesian product is returned when",
      "explanation": "A Cartesian product is returned when join conditions are not specified in a PROC SQL join. In a Cartesian product, each row from the first table is combined with every row from the second table.",
      "options": [
        {
          "tag": "A",
          "description": "A. join conditions are not specified in a PROC SQL join.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. join conditions are not specified in a PROC SQL set operation.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. more than two tables are specified in a PROC SQL join.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. the keyword ALL is used with the OUTER UNION operator.",
          "correct": false
        }
      ]
    },
    {
      "number": "83",
      "description": "Given the PROC SQL query and tables shown below, which output is generated?\nSTORE1\nWK    SALES\n1         $515.07\n2         $772.29\n3         $888.88\n4         $1000.01\n\nSTORE2\nWK    SALES\n1         $1368.99\n2         $1506.23\n3         $1200.57\n4         $1784.11\n5         $43.00\n\nproc sql;\nselect *\nfrom store1,\nstore2\nwhere store1.wk=\nstore2.wk;",
      "explanation": "This PROC SQL query is an inner join. It combines the rows from the first table that match rows from the second table, based on the matching criteria specified in the WHERE clause. Columns are not overlaid, so all columns from the referenced tables (including any columns with duplicate names) are displayed. Any unmatched rows from either table are not displayed.",
      "options": [
        {
          "tag": "A",
          "description": "A. WK   SALES       WK      SALES\n    1   $515.07     1       $1368.99\n    2   $772.29     2       $1506.23\n    3   $888.88     3       $1200.57\n    4   $1000.01    4       $1784.11\n    5                       $43.00",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. WK   SALES       WK      SALES\n    1   $515.07     1       $1368.99\n    2   $772.29     2       $1506.23\n    3   $888.88     3       $1200.57\n    4   $1000.01    4       $1784.11",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. WK       SALES\n    1       $515.07\n    2       $772.29\n    3       $888.88\n    4       $1000.01",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. WK       SALES\n    1       $515.07\n    2       $772.29\n    3       $888.88\n    4       $1000.01\n    1       $1368.99\n    2       $1506.23\n    3       $1200.57\n    4       $1784.11",
          "correct": false
        }
      ]
    },
    {
      "number": "84",
      "description": "Given the PROC SQL query and tables shown below, which output is generated?\nBONUS\nID        BONUS\n123      5000\n456      7000\n744      3500\n\nSALARY\nID         SALARY\n123      70000\n456      80000\n978      55000\n\nproc sql;\nselect s.*, bonus\nfrom bonus as b\nright join\nsalary as s\non b.id=\ns.id;",
      "explanation": "This PROC SQL query is a right outer join, which retrieves all rows that match across tables, based on the join conditions in the ON clause, plus nonmatching rows from the right (second) table.",
      "options": [
        {
          "tag": "A",
          "description": "A. ID       SALARY  BONUS\n   123      70000   5000\n   456      80000   7000\n   978      55000   3500",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. ID       SALARY  BONUS\n   123      70000   5000\n   456      80000   7000\n   744      .       3500",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. ID       SALARY  BONUS\n   123      70000   5000\n   456      80000   7000\n   744      55000   3500",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. ID       SALARY      BONUS\n   123      70000       5000\n   456      80000       7000\n   978      55000       .",
          "correct": true
        }
      ]
    },
    {
      "number": "85",
      "description": "Which PROC SQL query produces the same output as the query shown here?\n\nproc sql;\nselect a.*,\nduration\nfrom groupa as a,\ngroupb as b\nwhere a.obs=b.obs;\n\nNote:Assume that the table Groupa contains the columns Obs and Med. Groupb contains the columns Obs and Duration.",
      "explanation": "There are two valid formats for writing a PROC SQL inner join. The PROC SQL query shown at the top of this question uses the first inner join format, which does not use a keyword to indicate the type of join. The alternate format is similar to an outer join and uses the keyword INNER JOIN.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nselect a.obs label='Obs',\nmed",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. obs label='Obs',\nduration\nfrom groupa as a, groupb as b\nwhere a.obs=b.obs;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nselect coalesce(a.obs, b.obs)\nlabel='Obs', med, duration\nfrom groupa as a\nfull join\ngroupb as b\non a.obs=b.obs;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nselect a.*, duration\nfrom groupa as a\ninner join\ngroupb as b\non a.obs=b.obs;",
          "correct": true
        }
      ]
    },
    {
      "number": "86",
      "description": "Which output is generated by the following PROC SQL query?\nTABLE1\nG3      Z\n89      FL\n46      UI\n47      BL\n\nTABLE2\nG3     R\n46     BC\n85     FL\n99     BA\n\nproc sql;\nselect *\nfrom table1\nleft join\ntable2\non table1.g3=\ntable2.g3;",
      "explanation": "This PROC SQL query is a left outer join, which retrieves all rows that match across tables (based on the join conditions in the ON clause), plus nonmatching rows from the left (first) table. No columns are overlaid, so all columns from both tables are displayed.",
      "options": [
        {
          "tag": "A",
          "description": "A. G3       Z       G3      R\n   89       FL      .\n   46       UI      46      BC\n   47       BL      .",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. G3       Z       G3      R\n   46       FL      46      BC\n   .                45      FL\n   .                99      BA",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. G3       Z\n   46       UI",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. G3       Z       G3      R\n   46       UI      46      BC",
          "correct": false
        }
      ]
    },
    {
      "number": "87",
      "description": "In order for PROC SQL to perform an inner join,",
      "explanation": "Inner joins combine the rows from the first table that match rows from the second table, based on one or more join conditions in the WHERE clause. The columns being matched must have the same data type, but they are not required to have the same name. For joins, the tables being joined can have different numbers of columns, and the rows do not need to be sorted.",
      "options": [
        {
          "tag": "A",
          "description": "A. the tables being joined must contain the same number of columns.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. the tables must be sorted before they are joineD.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. the columns that are specified in a join condition in the WHERE clause must have the same data type.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. the columns that are specified in a join condition in the WHERE clause must have the same name.",
          "correct": false
        }
      ]
    },
    {
      "number": "88",
      "description": "Which statement about in-line views is false?",
      "explanation": "Unlike a table, an in-line view exists only during query execution. Because it is temporary, an in-line view can be referenced only in the query in which it is defined.",
      "options": [
        {
          "tag": "A",
          "description": "A. Once defined, an in-line view can be referenced in any PROC SQL query in the current SAS session.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. An in-line view can be assigned a table alias but not a permanent name.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. In-line views can be combined with tables in PROC SQL joins.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. This PROC SQL query contains an in-line view that uses valid syntax:",
          "correct": false
        }
      ]
    },
    {
      "number": "89",
      "description": "Which PROC SQL query generates the same output as the DATA step match-merge and PRINT step shown below?\n\nTABLE1\nG3      Z\n46      UI\n47      BL\n89      FL\n\nTABLE2\nG3     R\n46     BC\n85     FL\n99     BA\n\nMERGED\nG3     R        Z\n46     UI       BC\n47     BA\n85              FL\n89     FL\n99              BA\n\ndata merged;\nmerge table1 table2;\nby g3;\nrun;\nproc print data=merged\nnoobs;\ntitle 'Merged';\nrun;",
      "explanation": "In order to generate the same output as the DATA step and PRINT steps, the PROC SQL full outer join must use the COALESCE function with the duplicate columns specified as arguments.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\ntitle 'Merged';\nselect a.g3, z, r\nfrom table1 as a\nfull join\ntable2 as b\non a.g3 = b.g3\norder by 1;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\ntitle 'Merged';\nselect a.g3, z, r\nfrom table1 as a\ntable2 as b\non a.g3 = b.g3\norder by 1;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\ntitle 'Merged';\nselect coalesce(a.g3, b.g3)\nlabel='G3', z, r\nfrom table1 as a\nfull join\ntable2 as b\non a.g3 = b.g3\norder by 1;",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. proc sql;\ntitle 'Merged';\nselect g3, z, r\nfrom table1 as a\nfull join\ntable2 as b\non a.g3 = b.g3\norder by 1;",
          "correct": false
        }
      ]
    },
    {
      "number": "90",
      "description": "A PROC SQL inner join can combine",
      "explanation": "A maximum of 256 tables can be combined in a single inner join. If the join involves views (either in-line views or PROC SQL views), it is the number of tables that underlie the views, not the number of views, that counts towards the limit of 256.",
      "options": [
        {
          "tag": "A",
          "description": "A. a maximum of 2 tables or in-line views, but multiple joins can be chained together.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. a maximum of 256 tables or 2 in-line views.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. a maximum of 256 tables, which includes any tables referenced by an in-line view.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. a maximum of 2 tables and 32 columns.",
          "correct": false
        }
      ]
    },
    {
      "number": "91",
      "description": "Which statement about the use of table aliases is false?",
      "explanation": "The use of summary functions does not require the use of table aliases. All of the other statements about table aliases that are shown here are true.",
      "options": [
        {
          "tag": "A",
          "description": "A. Table aliases must be used when referencing identical table names from different libraries.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. Table aliases can be referenced by using the keyword AS.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. Table aliases (or full table names) must be used when referencing a column name that is the same in two or more tables.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. Table aliases must be used when using summary functions.",
          "correct": true
        }
      ]
    },
    {
      "number": "92",
      "description": "Which statement is false with respect to a set operation that uses the EXCEPT, UNION, or INTERSECT set operator without a keyword?",
      "explanation": "In set operations that use the operator EXCEPT, INTERSECT, or UNION, and no keyword, columns are overlaid based on their position in the SELECT clause. It does not matter whether the overlaid columns have the same name. When columns are overlaid, the column name is taken from the first table that is specified in the SELECT clause.",
      "options": [
        {
          "tag": "A",
          "description": "A. Column names in the result set are determined by the first table.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. To be overlaid, columns must be of the same data type.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. To be overlaid, columns must have the same name.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. By default, only unique rows are displayed in the result set.",
          "correct": false
        }
      ]
    },
    {
      "number": "93",
      "description": "The keyword ALL cannot be used with which of the following set operators?",
      "explanation": "By default, when processing a set operation that contains the EXCEPT, INTERSECT, and UNION set operators, PROC SQL makes an extra pass through the data to eliminate duplicate rows. The keyword ALL is used to suppress that additional pass through the tables, allowing duplicate rows to appear in the result set. Because the OUTER UNION set operator displays all rows, the keyword ALL is invalid and cannot be used with OUTER UNION.",
      "options": [
        {
          "tag": "A",
          "description": "A. EXCEPT",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. INTERSECT",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. UNION",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. OUTER UNION",
          "correct": true
        }
      ]
    },
    {
      "number": "94",
      "description": "Which PROC SQL step combines the tables Summer and Winter to produce the output displayed below?\nSUMMER\nMonth   Temp    Precip\n7       78      .05\n8       85      .04\n9       83      .15\n\nWinter\nMonth   Temp    Precip\n1       29      .15\n2       32      .17\n3       38      .20\n2       32      .17\n\nMonth   Temp    Precip\n1       29      .15\n2       32      .17\n3       38      .20\n7       78      .05\n8       85      .04\n9       83      .15",
      "explanation": "The output contains all rows that are unique in the combined set of rows from both tables, and the columns have been overlaid by position. This output is generated by a set operation that uses the set operator UNION without keywords.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nselect *\nfrom summer\nintersect all\nselect *\nfrom winter;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nselect *\nfrom summer\nouter union\nselect *\nfrom winter;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nselect *\nfrom summer\nunion corr\nselect *\nfrom winter;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nselect *\nfrom summer\nunion\nselect *\nfrom winter;",
          "correct": true
        }
      ]
    },
    {
      "number": "95",
      "description": "Which PROC SQL step combines tables but does not overlay any columns?",
      "explanation": "The PROC SQL set operation that uses the set operator OUTER UNION without a keyword is the only code shown that does not overlay any columns in output.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nselect *\nfrom groupa\nouter union\nselect *\nfrom groupb;",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nselect *\nfrom groupa as a\nouter union corr\nselect *\nfrom groupb as b;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nselect coalesce(a.obs, b.obs)\nlabel='Obs', med, duration\nfrom groupa as a\nfull join\ngroupb as b\non a.obs=b.obs;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nselect *\nfrom groupa as a\nintersect\nselect *\nfrom groupb as b;",
          "correct": false
        }
      ]
    },
    {
      "number": "96",
      "description": "Which statement is false regarding the keyword CORRESPONDING?",
      "explanation": "The keyword CORRESPONDING (CORR) can be used alone or together with the keyword ALL.",
      "options": [
        {
          "tag": "A",
          "description": "A. It cannot be used with the keyword ALL.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. It overlays columns by name, not by position.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. When used in EXCEPT, INTERSECT, and UNION set operations, it removes any columns not found in both tables.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. When used in OUTER UNION set operations, it causes same-named columns to be overlaid.",
          "correct": false
        }
      ]
    },
    {
      "number": "97",
      "description": "Which PROC SQL step generates the following output from the tables Dogs and Pets?\nDOGS\nName        Price\nFIFI        $101\nGEORGE      $75\nSPARKY      $136\nTRUFFLE     $250\n\nPETS\nNames       Price       Arr\nANA         $25         9JAN2002\nFIFI        $101        14MAR2002\nGAO         $57         8DEC2001\nGAO         $57         8DEC2001\nSPARKY      $136        16SEP2002\nTRUFFLE     $250        20DEC2002\nZEUS        $500        8JUN2002\n\nNAME        PRICE\nANA         $25\nGAO         $57\nZEUS        $500",
      "explanation": "This PROC SQL output includes all rows from the table Pets that do not appear in the table Dogs. No duplicates are displayed. A PROC SQL set operation that contains the set operator EXCEPT without keywords produces these results.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nselect name, price\nfrom pets\nexcept all\nselect *\nfrom dogs;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nselect name, price\nfrom pets\nexcept\nselect *\nfrom dogs;",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nselect name, price\nfrom pets\nexcept corr all\nselect *\nfrom dogs;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nselect *\nfrom dogs\nexcept corr\nselect name, price\nfrom pets;",
          "correct": false
        }
      ]
    },
    {
      "number": "98",
      "description": "The PROG1 and PROG2 tables list students who took the PROG1 and PROG2 courses, respectively. Which PROC SQL step gives you the names of the students who took only the PROG1 class?\n\nPROG1\nFNAME       LNAME\nPete        Henry\nMary        Johnson\nAlex        Kinsley\nDori        O'niel\n\nPROG2\nFNAME       LNAME\nClara       Adams\nPete        Henry\nDori        O'niel\nCindy       Philips\nMandy       Young\n\nPROG1 Only\nFNAME       LNAME\nAlex        Kinsley\nMary        Johnson",
      "explanation": "The set operator EXCEPT returns all the rows in the first table that do not appear in the second table. The keyword ALL suppresses the extra pass that PROC SQL makes through the data to eliminate duplicate rows. The EXCEPT operator when used alone will also produce the output specified in the question.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nselect fname, lname\nfrom prog1\nintersect\nselect fname, lname\nfrom prog2;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nselect fname, lname\nfrom prog1\nexcept all\nselect fname, lname\nfrom prog2;",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nselect *\nfrom prog2\nintersect corr\nselect *\nfrom prog1;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nselect *\nfrom prog2\nunion\nselect *\nfrom prog1;",
          "correct": false
        }
      ]
    },
    {
      "number": "99",
      "description": "Which PROC SQL step returns the names of all the students who took PROG1, PROG2, or both classes?\nPROG1\nFNAME       LNAME\nPete        Henry\nMary        Johnson\nAlex        Kinsley\nDori        O'niel\n\nPROG2\nFNAME       LNAME\nClara       Adams\nPete        Henry\nDori        O'niel\nCindy       Philips\nMandy       Young\n\nPROG1 PROG2 or BOTH\nFNAME       LNAME\nAlex        Kinsley\nCindy       Philips\nClara       Adams\nDori        O'niel\nMandy       Young\nMary        Johnson\nPete        Henry",
      "explanation": "The set operator UNION returns all rows that are unique in the combined set of rows from both tables.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nselect fname, lname\nfrom prog1\nintersect\nselect fname, lname\nfrom prog2;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nselect fname, lname\nfrom prog1\nouter union corr\nselect fname, lname\nfrom prog2;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nselect fname, lname\nfrom prog1\nunion\nselect fname, lname\nfrom prog2;",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nselect fname, lname\nfrom prog1\nexcept corr\nselect fname, lname\nfrom prog2;",
          "correct": false
        }
      ]
    },
    {
      "number": "100",
      "description": "Which PROC SQL step returns the names of all the students who took both the PROG1 and PROG2 classes?\n\nPROG1\nFNAME       LNAME\nPete        Henry\nMary        Johnson\nAlex        Kinsley\nDori        O'niel\n\nPROG2\nFNAME       LNAME\nClara       Adams\nPete        Henry\nDori        O'niel\nCindy       Philips\nMandy       Young\n\nPROG1 PROG2\nFNAME       LNAME\nDori        O'niel\nPete        Henry",
      "explanation": "The set operator INTERSECT returns all rows that are common to both tables. Specifying the keyword ALL suppresses PROC SQL's additional pass through the data to eliminate duplicate rows.\n",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nselect fname, lname\nfrom prog1\nunion\nselect fname, lname\nfrom prog2;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nselect fname, lname\nfrom prog1\nexcept corr\nselect fname, lname\nfrom prog2;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nselect fname, lname\nfrom prog1\nintersect all\nselect fname, lname\nfrom prog2;",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nselect fname, lname\nfrom prog1\nunion corr\nselect fname, lname\nfrom prog2;",
          "correct": false
        }
      ]
    },
    {
      "number": "101",
      "description": "Which PROC SQL step generates the same results as the following DATA step?\n\nPROG1\nFNAME       LNAME\nPete        Henry\nMary        Johnson\nAlex        Kinsley\nDori        O'niel\n\nPROG2\nFNAME       LNAME\nClara       Adams\nPete        Henry\nDori        O'niel\nCindy       Philips\nMandy       Young\n\ndata allstudents;\nset prog1 prog2;\nby lname;\nrun;\nproc print noobs;\nrun;",
      "explanation": "The DATA step returns all rows from the first table along with all rows from the second table, maintaining the order specified in the BY statement. Same-named columns are overlaid by default. The set operator OUTER UNION returns all rows from both tables. The CORR keyword causes same-named columns to be overlaid. The ORDER BY clause causes the result rows to be ordered by values of the specified column (LName).\n",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nselect fname, lname\nfrom prog1\nouter union corr\nselect fname, lname\nfrom prog2\norder by lname;",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nselect fname, lname\nfrom prog1\nunion\nselect fname, lname\nfrom prog2\norder by lname;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nselect fname, lname\nfrom prog2\nouter union\nselect fname, lname\nfrom prog1\norder by lname;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nselect fname, lname\nfrom prog2\nunion corr\nselect fname, lname\nfrom prog1\norder by lname;",
          "correct": false
        }
      ]
    },
    {
      "number": "102",
      "description": "Which of the following PROC SQL steps creates a new table by copying only the column structure (but not the rows) of an existing table?",
      "explanation": "The CREATE TABLE statement that includes a LIKE clause copies the column names and attributes from an existing table into a new table. No rows of data are inserted.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\ncreate table work.newpayroll as\nselect *\nfrom sasuser.payrollmaster;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\ncreate table work.newpayroll\nlike sasuser.payrollmaster;",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. proc sql;\ncreate table work.newpayroll\ncopy sasuser.payrollmaster;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\ncreate table work.newpayroll\ndescribe sasuser.payrollmaster;",
          "correct": false
        }
      ]
    },
    {
      "number": "103",
      "description": "Which of the following PROC SQL steps creates a table that contains rows for the level-1 flight attendants only?",
      "explanation": "The CREATE TABLE statement that includes the AS keyword and query clauses creates a table and loads the results of the query into the new table. The WHERE clause selects only the rows for the level-1 flight attendants.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\ncreate table work.newpayroll as\nselect *\nfrom sasuser.payrollmaster\nwhere jobcode='FA1';",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. proc sql;\ncreate work.newpayroll as\nselect *\nfrom sasuser.payrollmaster\nwhere jobcode='FA1';",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\ncreate table work.newpayroll\ncopy sasuser.payrollmaster\nwhere jobcode='FA1';",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\ncreate table work.newpayroll as\nsasuser.payrollmaster\nwhere jobcode='FA1';",
          "correct": false
        }
      ]
    },
    {
      "number": "104",
      "description": "Which of the following statements is true regarding the UNDO_POLICY=REQUIRED option?",
      "explanation": "UNDO POLICY=REQUIRED is the default setting for PROC SQL. This setting undoes all inserts or updates if 1 or more rows violate the integrity constraint criteria, and restores the table to its original state before the inserts or updates.\n",
      "options": [
        {
          "tag": "A",
          "description": "A. It must be used with the REQUIRED integrity constraint.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. It ignores the specified integrity constraints if any of the rows that you want to insert or update do not meet the constraint criteria.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. It restores your table to its original state if any of the rows that you try to insert or update do not meet the specified integrity constraint criteria.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. It allows rows that meet the specified integrity constraint criteria to be inserted or updated, but rejects rows that do not meet the integrity constraint criteria.",
          "correct": false
        }
      ]
    },
    {
      "number": "105",
      "description": "Which of the following is not a type of integrity constraint?",
      "explanation": "The NOT NULL integrity constraint specifies that data is required and cannot have a null (missing) value.",
      "options": [
        {
          "tag": "A",
          "description": "A. CHECK",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. NULL",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. UNIQUE",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. PRIMARY KEY",
          "correct": false
        }
      ]
    },
    {
      "number": "106",
      "description": "Which of the following PROC SQL steps deletes rows for all frequent-flyer program members who traveled less than 10,000 miles?",
      "explanation": "The DELETE statement deletes rows that are specified in the WHERE clause from the table. If no WHERE clause is specified, all rows are deleted. The DROP TABLE statement drops (deletes) an entire table; the syntax shown in option c is not valid.\n",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\ndelete rows\nfrom work.frequentflyers\nwhere milestraveled < 10000;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\ndrop rows\nfrom work.frequentflyers\nwhere milestraveled < 10000;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\ndrop table\nfrom work.frequentflyers\nwhere milestraveled < 10000;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\ndelete\nfrom work.frequentflyers\nwhere milestraveled < 10000;",
          "correct": true
        }
      ]
    },
    {
      "number": "107",
      "description": "Which of the following PROC SQL steps gives bonuses (in points) to frequent-flyer program members as follows:\na 50% bonus for members who traveled less than 10,000 miles\na 100% bonus for members who traveled 10,000 miles or more?",
      "explanation": "The UPDATE statement that includes a SET clause is used to modify rows in a table. WHEN-THEN clauses in the CASE expression enable you to update a column value based on specified criteria.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nupdate work.frequentflyers\nset pointsearned=pointsearned*\ncase if milestraveled < 10000\nthen 1.5\nif milestraveled >= 10000\nthen 2\nelse 1\nend;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nupdate work.frequentflyers\nset pointsearned=pointsearned*\ncase when milestraveled < 10000\nthen 1.5\nwhen milestraveled >= 10000\nthen 2\nelse 1\nend;",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nupdate work.frequentflyers\nset pointsearned=pointsearned*\ncase if milestraveled < 10000\nthen pointsearned*1.5\nif milestraveled >= 10000\nthen pointsearned*2\nelse 1\nend;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nupdate work.frequentflyers\nset pointsearned=pointsearned*\ncase if milestraveled < 10000\nthen pointsearned*1.5\nif milestraveled >= 10000\nthen pointsearned*2\nelse pointsearned*1\nend;",
          "correct": false
        }
      ]
    },
    {
      "number": "108",
      "description": "Which of the following statements is used to add new rows to a table?",
      "explanation": "The INSERT statement is used to insert new rows into a new or existing table. There is no LOAD statement in PROC SQL, VALUES is a clause, and the CREATE TABLE statement is used to create a table.",
      "options": [
        {
          "tag": "A",
          "description": "A. INSERT",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. LOAD",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. VALUES",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. CREATE TABLE",
          "correct": false
        }
      ]
    },
    {
      "number": "109",
      "description": "Which of the following statements regarding the ALTER TABLE statement is false?",
      "explanation": "The ALTER TABLE statement is used to modify attributes of existing columns (include the MODIFY clause), add new column definitions (include the ADD clause), or delete existing columns (include the DROP clause).",
      "options": [
        {
          "tag": "A",
          "description": "A. It enables you to update column attributes.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. It enables you to add new columns in your table.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. It enables you to drop columns in your table.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. It enables you to change a character column to a numeric column.",
          "correct": true
        }
      ]
    },
    {
      "number": "110",
      "description": "Which of the following displays the structure of a table in the SAS log?",
      "explanation": "The DESCRIBE TABLE statement lists the column attributes for a specified table.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\ndescribe as\nselect *\nfrom sasuser.payrollmaster;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\ndescribe contents sasuser.payrollmaster;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\ndescribe table sasuser.payrollmaster;",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. proc sql;\ndescribe * from sasuser.payrollmaster;",
          "correct": false
        }
      ]
    },
    {
      "number": "111",
      "description": "Which of the following creates an empty table that contains the two columns FullName and Age?",
      "explanation": "The CREATE TABLE statement can include column specifications to create an empty table. The entire group of column specifications must be enclosed in a single set of parentheses. You must list each column's name, data type, and (for character columns) length. The length is specified as an integer in parentheses. Multiple column specifications must be separated by commas.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\ncreate table work.names\n(FullName char(25), Age num);",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. proc sql;\ncreate table work.names as\n(FullName char(25), Age num);",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\ncreate work.names\n(FullName char(25), Age num);",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\ncreate table work.names\nset (FullName char(25), Age num);",
          "correct": false
        }
      ]
    },
    {
      "number": "112",
      "description": "Which of the following creates an index on the column EmpID for the table Sasuser.Staffmaster?",
      "explanation": "The index that is specified is based on one column, so it is a simple index. In the CREATE INDEX statement, you specify the index name after the keywords CREATE INDEX. You do not include a keyword to specify that this is a simple index. The name of the key column is specified in parentheses after the table name. The name of a simple index must be the same as the name of the key column.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\ncreate simple index(empid)\non sasuser.staffmaster;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\ncreate empid index\non sasuser.staffmaster(empid);",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\ncreate simple index\non empid from sasuser.staffmaster;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\ncreate index empid\non sasuser.staffmaster(empid);",
          "correct": true
        }
      ]
    },
    {
      "number": "113",
      "description": "Which keyword must you add to your index definition in the CREATE INDEX statement to ensure that no duplicate values of the key column can exist?",
      "explanation": "To create a unique index, the UNIQUE keyword is added to the CREATE INDEX statement, between the keywords CREATE and INDEX.",
      "options": [
        {
          "tag": "A",
          "description": "A. KEY",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. UNIQUE",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. NODUPS",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. NODUPKEY",
          "correct": false
        }
      ]
    },
    {
      "number": "114",
      "description": "Which of the following creates a composite index for the table Sasuser.Flightdelays? (Sasuser.Flightdelays contains the following columns: Date, FlightNumber, Origin, Destination, DelayCategory, DestinationType, DayOfWeek, and Delay.)",
      "explanation": "A composite index is based on two or more columns. In the CREATE INDEX statement, you specify the index name after the keywords CREATE INDEX. You do not include a keyword to specify that this is a composite index. The names of the key columns are specified in parentheses after the table name. The name of a composite index cannot be the same as the name of any columns in the table.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\ncreate index destination\non sasuser.flightdelays(flightnumber,\ndestination);",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\ncreate composite index places\non sasuser.flightdelays (flightnumber,\ndestination);",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\ncreate index on flightnumber,destination\nfrom sasuser.flightdelays (places);",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\ncreate index places\non sasuser.flightdelays (flightnumber,\ndestination);",
          "correct": true
        }
      ]
    },
    {
      "number": "115",
      "description": "Which of the following writes a message to the SAS log that shows whether PROC SQL has used an index?",
      "explanation": "Specifying the option MSGLEVEL=I causes informational messages about index usage to be written to the SAS log.",
      "options": [
        {
          "tag": "A",
          "description": "A. options msglevel=i;\nproc sql;\nselect *\nfrom sasuser.internationalflights\nwhere date between '01mar2000'd\nand '07mar2000'd;",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. options index=yes;\nproc sql;\nselect *\nfrom sasuser.internationalflights\nwhere date between '01mar2000'd\nand '07mar2000'd;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nselect * (idxwhere=yes)\nfrom sasuser.internationalflights\nwhere date between '01mar2000'd\nand '07mar2000'd;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nselect * (msglevel=i)\nfrom sasuser.internationalflights\nwhere date between '01mar2000'd\nand '07mar2000'd;",
          "correct": false
        }
      ]
    },
    {
      "number": "116",
      "description": "Which of the following drops (deletes) an index from a table?",
      "explanation": "The DROP INDEX statement drops one or more specified indexes from a table. You specify the name of each index to be dropped after the keywords DROP INDEX. The table name is specified after the keyword FROM. The type of index and the names of the indexed columns are not specified in the statement.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\ndrop composite index flights\nfrom sasuser.marchflights;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\ndelete index flights\non sasuser.staffmaster(flightnumber, date);",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\ndrop index flights\nfrom sasuser.marchflights;",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. proc sql;\ndelete index\non sasuser.marchflights(flightnumber,\nflightdate);",
          "correct": false
        }
      ]
    },
    {
      "number": "117",
      "description": "Which of the following statements shows you all the indexes that are defined for a table?",
      "explanation": "The DESCRIBE TABLE statement lists all indexes for one or more tables that you specify, along with other information about the table(s).",
      "options": [
        {
          "tag": "A",
          "description": "A. DESCRIBE INDEX",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. DESCRIBE TABLE",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. SELECT",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. IDXNAME",
          "correct": false
        }
      ]
    },
    {
      "number": "118",
      "description": "What is the purpose of specifying the data set option IDXWHERE=YES?",
      "explanation": "The IDXWHERE=YES data set option tells SAS to use the best available index, even if the index does not optimize performance.",
      "options": [
        {
          "tag": "A",
          "description": "A. It forces SAS to use the best available index to process the WHERE expression.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. It creates an index from the expression in the WHERE clause.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. It writes messages about index usage to the SAS log.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. It stops SAS from using any index.",
          "correct": false
        }
      ]
    },
    {
      "number": "119",
      "description": "Which of the following is false regarding the use of an index?",
      "explanation": "Indexes can be created on either character or numeric columns.",
      "options": [
        {
          "tag": "A",
          "description": "A. Equijoins can be performed without internal sorts.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. Indexes provide fast access to a small subset of datA.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. Indexes can be created for numeric columns only.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. Indexes can enforce uniqueness.",
          "correct": false
        }
      ]
    },
    {
      "number": "120",
      "description": "Using an index is not likely to optimize a PROC SQL query in which of the following situations?",
      "explanation": "Using an index will optimize specific classes of PROC SQL queries. A query in which the key column is specified only in a SELECT clause is not one of these queries.",
      "options": [
        {
          "tag": "A",
          "description": "A. The query contains an IN subquery that references the key column.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. The key column is specified in a WHERE clause expression that contains a comparison operator, the TRIM or SUBSTR function, the CONTAINS operator, or the LIKE operator.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. The query is an equijoin, and all the columns in the join expression are indexed in one of the tables being joineD.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. The key column is specified only in a SELECT clause.",
          "correct": true
        }
      ]
    },
    {
      "number": "121",
      "description": "Which of the following is false regarding the IDXNAME= data set option?",
      "explanation": "The IDXNAME= data set option directs PROC SQL to use an index that you specify. The specified index must exist and must be suitable by having at least its first or only column match the condition in the WHERE expression.",
      "options": [
        {
          "tag": "A",
          "description": "A. The specified index must exist.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. The specified index must be suitable by having at least its first or only column match a condition in the WHERE expression.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. The option enables you to create and name an index on the table.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. The option directs SAS to use an index that you specify.",
          "correct": false
        }
      ]
    },
    {
      "number": "122",
      "description": "Which of the following statements is false regarding a PROC SQL view?",
      "explanation": "A PROC SQL view accesses the most current underlying data and can be joined with tables or other views. In addition, a PROC SQL view can be used in SAS programs in place of an actual SAS data file be derived from one or more tables, PROC SQL views, or DATA step views.",
      "options": [
        {
          "tag": "A",
          "description": "A. A view cannot be used in a join.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. A view accesses the most current underlying data.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. A view follows the same naming conventions as a table.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. A view can be used in SAS programs in place of an actual SAS data file.",
          "correct": false
        }
      ]
    },
    {
      "number": "123",
      "description": "Which of the following statements describes an advantage of using a PROC SQL view?",
      "explanation": "PROC SQL views are useful because they often save space (a view is usually quite small compared with the data that it accesses) prevent users from continually submitting queries to omit unwanted columns or rows hide complex joins or queries from users.\nIn addition, PROC SQL views ensure that input data sets are always current, because data is derived from tables at execution time can be used to shield sensitive or confidential columns from users while enabling the same users to view other columns in the same table.",
      "options": [
        {
          "tag": "A",
          "description": "A. Views often save space, because a view is usually quite small compared with the data that it accesses.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. Views prevent users from continually submitting queries to omit unwanted columns or rows.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. Views hide complex joins or queries from users.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. all of the above",
          "correct": true
        }
      ]
    },
    {
      "number": "124",
      "description": "Which PROC SQL step creates a view that queries the table Sasuser.Payrollmaster?",
      "explanation": "You use the CREATE VIEW statement to create a view. The keywords CREATE VIEW are followed by the name of the view and the keyword AS.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\ninsert into sasuser.newview\nselect * from sasuser.payrollmaster;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\ncreate sasuser.newview as\nselect * from sasuser.payrollmaster;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\ncreate view sasuser.newview as\nselect * from sasuser.payrollmaster;",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nselect * from sasuser.payrollmaster\ninto view sasuser.newview;",
          "correct": false
        }
      ]
    },
    {
      "number": "125",
      "description": "Which of the following PROC SQL steps enables you to see a description of the view definition?",
      "explanation": "The DESCRIBE VIEW statement displays the view definition in the SAS log.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nselect * from sasuser.payrollmasterv;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\ndescribe view sasuser.payrollmasterv;",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nlist sasuser.payrollmasterv;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\ncontents view=sasuser.payrollmasterv;",
          "correct": false
        }
      ]
    },
    {
      "number": "126",
      "description": "Which PROC SQL step correctly references the view Data.Empview?",
      "explanation": "A view can be used in a PROC SQL step just as you would use an actual SAS table.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nselect *\nfrom data.empview;",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nselect *\nfrom view data.empview;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nselect view *\nfrom data.empview;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nselect *\nfrom data\nwhere view='empview';",
          "correct": false
        }
      ]
    },
    {
      "number": "127",
      "description": "Which of the following PROC SQL steps correctly embeds a LIBNAME statement with a view definition?",
      "explanation": "The USING clause enables you to embed a LIBNAME statement in your view definition. The USING clause must be the last clause in the CREATE VIEW statement.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\ninsert into sasuser.newview\nselect * from airline.supervisors\nlibname airline 'c:\\mysql';",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\ncreate view sasuser.newview as\nfrom airline.supervisors\nembed libname airline 'c:\\mysql';",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nusing airline 'c:\\mysql';\ninsert into sasuser.newview\nselect * from airline.supervisors;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\ncreate view sasuser.newview as\nselect * from airline.supervisors\nusing libname airline 'c:\\mysql';",
          "correct": true
        }
      ]
    },
    {
      "number": "128",
      "description": "PROC SQL views can access data from:",
      "explanation": "PROC SQL views can access data from a SAS data file, a DATA step view, a PROC SQL view, or a relational database table.",
      "options": [
        {
          "tag": "A",
          "description": "A. a SAS data file.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. another PROC SQL view.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. a relational database table.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. all of the above",
          "correct": true
        }
      ]
    },
    {
      "number": "129",
      "description": "When you are working with PROC SQL views, it is best to:",
      "explanation": "When you are working with PROC SQL views, it is best to avoid using an ORDER BY clause in a view. If you specify an ORDER BY clause, the data must be sorted each time the view is referenced.\nAvoid creating views that are based on tables whose structure might change. A view is no longer valid when it references a nonexistent column.\nSpecify a one-level name in the FROM clause if the view resides in the same SAS data library as the contributing table(s). Using a one-level name in the FROM clause prevents you from having to change the view if you assign a different libref to the SAS data library that contains the view and its contributing table or tables.",
      "options": [
        {
          "tag": "A",
          "description": "A. avoid using an ORDER BY clause in a view.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. avoid creating views that are based on tables whose structure might change.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. specify a one-level name in the FROM clause if the view resides in the same SAS library as the contributing table(s).",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. all of the above",
          "correct": true
        }
      ]
    },
    {
      "number": "130",
      "description": "You can update the data underlying PROC SQL view using the INSERT, DELETE, and UPDATE statements under which of the following conditions:",
      "explanation": "You can update a PROC SQL view provided that the view does not join or link to another table, the view does not have a subquery, or you try to update a derived column. You can update a view  that contains a WHERE clause. The WHERE clause can be in the UPDATE clause or in the view. You cannot update a view that contains any other clause such as an ORDER BY or a HAVING  clause.",
      "options": [
        {
          "tag": "A",
          "description": "A. The view is joined or linked to another table.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. The view contains a subquery.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. The view contains a WHERE clause.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. all of the above",
          "correct": false
        }
      ]
    },
    {
      "number": "131",
      "description": "Which of the following programs drops (deletes) a view?",
      "explanation": "The DROP VIEW statement drops a view from the specified library.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\ndelete sasuser.newview;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\ndrop view sasuser.newview;",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nerase view sasuser.newview;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nremove newview from sasuser;",
          "correct": false
        }
      ]
    },
    {
      "number": "132",
      "description": "PROC SQL options are specified in",
      "explanation": "PROC SQL options are specified in the PROC SQL statement. After you specify an option, it remains in effect until you change it or you re-invoke PROC SQL.",
      "options": [
        {
          "tag": "A",
          "description": "A. the PROC SQL statement.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. an OPTIONS statement.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. a SELECT statement.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. the OPTIONS procedure.",
          "correct": false
        }
      ]
    },
    {
      "number": "133",
      "description": "Which of the following SQL options restricts the number of rows that PROC SQL takes as input from any single source?",
      "explanation": "The INOBS= option restricts the number of rows that PROC SQL takes as input from any single source. The INOBS= option is similar to the SAS system option OBS= and is useful for debugging  queries on large tables. The OUTOBS= option restricts the number of rows that PROC SQL displays or writes to a table.",
      "options": [
        {
          "tag": "A",
          "description": "A. OUTOBS=",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. INOBS=",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. OBS=",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. none of the above",
          "correct": false
        }
      ]
    },
    {
      "number": "134",
      "description": "Which of the following options does not affect the appearance of HTML, PDF, or RTF output?",
      "explanation": "The DOUBLE | NODOUBLE option specifies whether PROC SQL output is double-spaced in listing output. The FLOW | NOFLOW | FLOW=n | FLOW=n m option controls the appearance of wide character columns in listing output. Neither option affects the appearance of HTML output.",
      "options": [
        {
          "tag": "A",
          "description": "A. NUMBER | NONUMBER",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. DOUBLE | NODOUBLE",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. FLOW | NOFLOW | FLOW=n | FLOW=n m",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. b and c",
          "correct": true
        }
      ]
    },
    {
      "number": "135",
      "description": "Which of the following statements is true regarding the STIMER option in PROC SQL?",
      "explanation": "The STIMER | NOSTIMER option in PROC SQL specifies whether PROC SQL writes timing information for each statement to the SAS log, instead of as a cumulative value for the entire procedure. NOSTIMER is the default. In order to use the STIMER option in PROC SQL, the SAS system option STIMER (the default) must also be in effect. If you use the system option alone, you will receive timing information for the entire procedure, not on a statement-by-statement basis.",
      "options": [
        {
          "tag": "A",
          "description": "A. The STIMER option in PROC SQL writes timing information for each statement to the SAS log.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. The STIMER option in PROC SQL writes only cumulative timing information for the entire procedure to the SAS log.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. When using the STIMER option in PROC SQL, the SAS system option STIMER must also be in effect.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. a and c",
          "correct": true
        }
      ]
    },
    {
      "number": "136",
      "description": "A Dictionary table contains which of the following?",
      "explanation": "A Dictionary table is a special, read-only SAS data view that contains information about SAS data libraries, SAS data sets, SAS macros, and external files that are in use or available in the  current SAS session. A Dictionary table also contains the settings for SAS system options that are currently in effect.",
      "options": [
        {
          "tag": "A",
          "description": "A. information about SAS libraries.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. information about SAS data sets.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. information about SAS macros.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. all of the above",
          "correct": true
        }
      ]
    },
    {
      "number": "137",
      "description": "Dictionary tables are",
      "explanation": "Dictionary tables are created each time they are referenced in a SAS program, updated automatically, and limited to read-only access. Accessing a Dictionary table causes SAS to determine the  current state of the SAS session and return the information that you want.",
      "options": [
        {
          "tag": "A",
          "description": "A. created each time they are referenced in a SAS program.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. updated automatically.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. limited to Read-Only access.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. all of the above",
          "correct": true
        }
      ]
    },
    {
      "number": "138",
      "description": "Dictionary tables can be accessed",
      "explanation": "Dictionary tables can be accessed by running a PROC SQL query against the table, using the Dictionary libref. Though SAS librefs are usually limited to eight characters, Dictionary is an  automatically assigned, reserved word. You can also access a Dictionary table by referring to the PROC SQL view of the table that is stored in the Sashelp library.",
      "options": [
        {
          "tag": "A",
          "description": "A. by running a PROC SQL query against the table, using the Dictionary libref.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. by referring to the PROC SQL view of the table that is stored in the Sashelp library.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. by referring to the PROC SQL view of the table that is stored in the Sasuser library.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. a and b",
          "correct": true
        }
      ]
    },
    {
      "number": "139",
      "description": "Which of the following PROC SQL steps displays information about the Dictionary table Dictionary.Titles?",
      "explanation": "To see how a Dictionary table is defined, submit a DESCRIBE TABLE statement. The DESCRIBE TABLE statement writes a CREATE TABLE statement to the SAS log for the table specified in  the DESCRIBE TABLE statement.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\ndescribe dictionary.titles;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\ndescribe table dictionary.titles;",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. proc sql describe table dictionary.titles;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql describe dictionary titles;",
          "correct": false
        }
      ]
    },
    {
      "number": "140",
      "description": "Which of the following PROC SQL steps displays the name (Memname), modification date (Modate), number of variables (Nvar), and the number of observations (Nobs) for each table in the Sasuser library?",
      "explanation": "To display information about the files in a specific library, specify the column names in a SELECT statement and the Dictionary table name in the FROM clause. The library name in the WHERE  clause must be specified in uppercase letters because that is how it is stored in SAS and it must be enclosed in quotation marks.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nselect memname, modate, nvar, nobs\nfrom dictionary.tables\nwhere libname='SASUSER';",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nselect memname, modate, nvar, nobs\nfrom dictionary.tables\nwhere libname='Sasuser';",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\nselect memname, modate, nvar, nobs\nfrom 'SASUSER'\nwhere table=dictionary.tables;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nselect SASUSER\nfrom dictionary.tables\nwhere cols= 'memname, modate, nvar, nobs';",
          "correct": false
        }
      ]
    },
    {
      "number": "141",
      "description": "Which of the following statements is false?",
      "explanation": "Macro variables are always text strings that are independent of SAS data sets. The value of a macro variable can be up to 65,534 characters long, and the name of a macro variable can be up to  32 characters long. A macro variable can be defined or referenced anywhere in a SAS program except within data lines. There are two types of macro variables: automatic and user-defined.",
      "options": [
        {
          "tag": "A",
          "description": "A. A macro variable can be defined and referenced anywhere in a SAS program except within data lines.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. Macro variables are always user-defined, and their values remain constant until they are changed by the user.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. Macro variables are text strings that are independent of SAS data sets.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. The values of macro variables can be up to 65,534 characters long.",
          "correct": false
        }
      ]
    },
    {
      "number": "142",
      "description": "Which of the following TITLE statements correctly references the macro variable month?",
      "explanation": "To reference a macro variable, you precede the name with an ampersand. You do not need to enclose the macro variable reference in quotation marks.",
      "options": [
        {
          "tag": "A",
          "description": "A. title \"Total Sales for '&month' \";",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. title \"Total Sales for 'month'\";",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. title \"Total Sales for &month\";",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. title Total Sales for \"&month\";",
          "correct": false
        }
      ]
    },
    {
      "number": "143",
      "description": "Which of the following statements generates an error message while trying to display the value of the macro variable month in the SAS log?",
      "explanation": "There are two ways to display the value of a macro variable in the SAS log: you can turn on the SYMBOLGEN system option to list the values of all macro variables that are used, or you can use  the %PUT statement to write specific text, including macro variable values, to the log.",
      "options": [
        {
          "tag": "A",
          "description": "A. options &month;",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. %PUT &month;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. options symbolgen;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. %PUT the macro variable MONTH has the value &month.;",
          "correct": false
        }
      ]
    },
    {
      "number": "144",
      "description": "Which statement creates a macro variable named location that has the value storage?",
      "explanation": "There are two ways to display the value of a macro variable in the SAS log: you can turn on the SYMBOLGEN system option to list the values of all macro variables that are used, or you can use  the %PUT statement to write specific text, including macro variable values, to the log.",
      "options": [
        {
          "tag": "A",
          "description": "A. &let location = storage;",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. let &location = storage;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. %let location = \"storage\";",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. %let location = storage;",
          "correct": false
        }
      ]
    },
    {
      "number": "145",
      "description": "What value do these statements assign to the macro variable reptitle:\n%let area = \"Southeast\";\n%let reptitle = * Sales Report for &area Area *;",
      "explanation": "Macro variables are stored as character strings. Quotation marks and most special characters are stored exactly as they are assigned, but leading blanks are stripped from assigned values. You  can also include references to other macro variables within %LET statements.",
      "options": [
        {
          "tag": "A",
          "description": "A. Sales Report for Southeast Area",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. Sales Report for \"Southeast\" Area",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. *Sales Report for \"Southeast\" Area*",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. * Sales Report for \"Southeast\" Area *",
          "correct": true
        }
      ]
    },
    {
      "number": "146",
      "description": "Assuming that you began your SAS session today, which of the following statements correctly sets the macro variable currdate to today's date:",
      "explanation": "SYSDATE9 is an automatic macro variable that stores the date that your SAS session began in ddmmmyyyy format. You can use the %SYSFUNC function along with any DATA step function, so  both the TODAY() function and the DATE() function will result in the current date.",
      "options": [
        {
          "tag": "A",
          "description": "A. %let currdate = %sysfunc(today(), worddate.);",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. %let currdate = &sysdate9;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. %let currdate = %sysfunc(date());",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. all of the above",
          "correct": true
        }
      ]
    },
    {
      "number": "147",
      "description": "Macro character functions",
      "explanation": "Macro character functions such as %UPCASE and %SUBSTR enable you to perform character manipulations on your macro variable values.",
      "options": [
        {
          "tag": "A",
          "description": "A. can be used to manipulate character strings in macro variable values.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. have the same basic syntax as the corresponding DATA step functions and yield similar results.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. all of the above",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. none of the above",
          "correct": false
        }
      ]
    },
    {
      "number": "148",
      "description": "The four types of tokens that SAS recognizes are",
      "explanation": "The word scanner recognizes four types of tokens. Expressions are not a type of token.",
      "options": [
        {
          "tag": "A",
          "description": "A. expressions, literals, names, and special characters.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. literals, names, numbers, and special characters.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. expressions, names, numbers, and special characters.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. expressions, literals, numbers, and special characters.",
          "correct": false
        }
      ]
    },
    {
      "number": "149",
      "description": "What are the resulting values for the macro variables that are defined here?\n\n%let month1 = June;\n%let month2 = July;\n%let period1 = &month1&month2;\n%let period2 = May&month1;\n%let period3 = &month2.Aug;",
      "explanation": "You can combine macro variable references with text to create new text strings. If you precede a macro variable with text, the ampersand at the beginning of the macro variable name signals the  end of the text and the beginning of a macro variable name. If you want text to follow the macro variable value, you must signal the end of the macro variable name with a period.",
      "options": [
        {
          "tag": "A",
          "description": "A. month1 Junemonth2 Julyperiod1 June Julyperiod2 May Juneperiod3 July Aug",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. month1 Junemonth2 Julyperiod1 JuneJulyperiod2 MayJuneperiod3 July.Aug",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. month1 Junemonth2 Julyperiod1 JuneJulyperiod2 MayJuneperiod3 JulyAug",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. month1 Junemonth2 Julyperiod1 junejulyperiod2 Mayjuneperiod3 julyaug",
          "correct": false
        }
      ]
    },
    {
      "number": "150",
      "description": "Which of the following correctly produces a title in which the current date is left-justified in order to remove extra blanks?",
      "explanation": "You use the %QSYSFUNC function in this case, in order to mask the comma that results from the worddate. format. You must mask this comma since the LEFT() function expects only one  argument.",
      "options": [
        {
          "tag": "A",
          "description": "A. title \"Report for %sysfunc(left(%sysfunc(today(),worddate.)))\";",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. title \"Report for %sysfunc(left(today(), worddate.))\";",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. title \"Report for %sysfunc(left(%qsysfunc(today(), worddate.)))\";",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. title \"Report for %left(today(), worddate.))\";",
          "correct": false
        }
      ]
    },
    {
      "number": "151",
      "description": "Which of the following is false?",
      "explanation": "Most macro functions are handled by the macro processor before any SAS language statements in the DATA step are executed. For example, the %LET statement and any macro variable  references (&macvar) are passed to the macro processor before the program is compiled. In order to create or update macro variables during DATA step execution, you use the SYMPUT routine.",
      "options": [
        {
          "tag": "A",
          "description": "A. A %LET statement causes the macro processor to create a macro variable before the program is compiled.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. To create a macro variable that is based on data calculated by the DATA step, you use the SYMPUT function.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. Macro functions are always processed during the execution of the DATA step.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. Macro variable references in a DATA step are always resolved before DATA step execution.",
          "correct": false
        }
      ]
    },
    {
      "number": "152",
      "description": "Which of the following correctly creates a macro variable named region and assigns to it a value that is based on the value of the data set variable Location?",
      "explanation": "To create a macro variable and assign to it a value that is based on the value of a DATA step variable, you use the SYMPUT routine. In the SYMPUT routine, to assign a literal string as a macro  variable name, you enclose the literal in quotation marks. To assign a literal string as a value of the macro variable, you enclose the literal in quotation marks.",
      "options": [
        {
          "tag": "A",
          "description": "A. data new;\nset sasuser.all;\nif location='Boston' then do;\ncall symput('region', 'East');\nend;\nelse do;\ncall symput('region', 'West');\nend;\nrun;",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. data new;\nset sasuser.all;\nif location='Boston' then do;\n%let region=East;\nend;\nelse\n%let region=West;\nend;\nrun;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. data new;\nset sasuser.all;\nif location='Boston' then do;\ncall symput(region, \"East\");\nend;\nelse\ncall symput(region, \"West\");\nend;\nrun;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. data new;\nset sasuser.all;\nif location='Boston' then do;\nsymput(region, East);\nend;\nelse\nsymput(region, West);\nend;\nrun;",
          "correct": false
        }
      ]
    },
    {
      "number": "153",
      "description": "The SYMPUT routine cannot",
      "explanation": "The SYMPUT routine enables you to assign a data set variable as the value of a macro variable. You can also use the SYMPUT routine to create a series of related macro variables. Because all  macro variable values are character strings, SYMPUT automatically converts any numeric value that you attempt to assign as a value for a macro variable. In an SCL program, you must use  SYMPUTN rather than SYMPUT if you are attempting to assign a numeric value to a macro variable.",
      "options": [
        {
          "tag": "A",
          "description": "A. be used to assign a data set variable as a value to a macro variable.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. create a series of macro variables in one DATA step.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. automatically convert a numeric value to a character value when used to assign a value to a macro variable in a DATA step.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. be used to assign a numeric value to a macro variable in an SCL program.",
          "correct": true
        }
      ]
    },
    {
      "number": "154",
      "description": "Which of the following programs correctly creates a series of macro variables whose names are values of the data set variable Course_code, then indirectly references one of those macro variables in a later step?",
      "explanation": "You can use multiple ampersands to create an indirect reference when the value of one macro variable is the name of another. If you enclose the DATA step variable name in quotation marks in the  SYMPUT routine, the new macro variable will have the same name as the DATA step variable rather than having the DATA step variable's value as a name. Use the SYMGET function to obtain the value of a macro variable during the execution of a DATA step.",
      "options": [
        {
          "tag": "A",
          "description": "A. data _null_;\nset sasuser.courses;\ncall symput(course_code, trim(course_title));\n%let crsid=C005;\nproc print data=sasuser.schedule noobs label;\nwhere course_code=\"&crsid\";\nvar location begin_date teacher;\ntitle1 \"Schedule for &c005\";\nrun;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. data _null_;\nset sasuser.courses;\ncall symput(course_code, trim(course_title));\nrun;\n%let crsid=C005;\nproc print data=sasuser.schedule noobs label;\nwhere course_code=\"&crsid\";\nvar location begin_date teacher;\ntitle1 \"Schedule for &&&crsid\";\nrun;",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. data _null_;\nset sasuser.courses;\ncall symput('course_code', trim(course_title));\nrun;\n%let crsid=C005;\nproc print data=sasuser.schedule noobs label;\nwhere course_code=\"&crsid\";\nvar location begin_date teacher;\ntitle1 \"Schedule for &&&crsid\";\nrun;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. data _null_;\nset sasuser.courses;\ncall symget(course_code, trim(course_title));\nrun;\n%let crsid=C005;\nproc print data=sasuser.schedule noobs label;\nwhere course_code=\"&crsid\";\nvar location begin_date teacher;\ntitle1 \"Schedule for &&&crsid\";\nrun;",
          "correct": false
        }
      ]
    },
    {
      "number": "155",
      "description": "Which of the following statements about the resolution of macro variable references is false?",
      "explanation": "If more than four consecutive ampersands precede a name token, rescanning continues from left to right until no more triggers can be resolved. The Forward Re-scan rule describes how the macro processor resolves macro variable references that start with multiple ampersands or with multiple percent signs.",
      "options": [
        {
          "tag": "A",
          "description": "A. Two ampersands resolve to one ampersand.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. If more than four consecutive ampersands precede a name token, the macro processor generates an error message.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. Re-scanning continues until there are no remaining macro triggers that the macro processor can resolve.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. The macro processor always re-scans a name token that is preceded by multiple ampersands or by multiple percent signs.",
          "correct": false
        }
      ]
    },
    {
      "number": "156",
      "description": "In which of the following situations would you use SYMGET rather than a macro variable reference (&macvar)?",
      "explanation": "A macro variable reference (&macvar) is resolved before any SAS language statements are sent to the compiler. The SYMGET function enables you to obtain the value of a macro variable during  the execution of a DATA step or a PROC SQL step. The SYMGET function can also be used to obtain the value of a macro variable during the execution of an SCL program.",
      "options": [
        {
          "tag": "A",
          "description": "A. to create a DATA step variable from a macro variable value during the execution of the DATA step",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. to include a macro variable reference in a PROC SQL view",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. to access the value of a macro variable during the execution of an SCL program",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. all of the above",
          "correct": true
        }
      ]
    },
    {
      "number": "157",
      "description": "Which of the following correctly creates a macro variable in a PROC SQL step?",
      "explanation": "To create a macro variable during the execution of a PROC SQL step, use the INTO clause of the SELECT statement. In the INTO clause, you precede the name of the macro variable with a colon.",
      "options": [
        {
          "tag": "A",
          "description": "A. call symput(daily_fee, put(fee/days, dollar8.);",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. %let daily_fee=put(fee/days, dollar8.)",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. select fee/days format=dollar8.\ninto :daily_fee from sasuser.all;",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. select fee/days format=dollar8.\ninto daily_fee from sasuser.all;",
          "correct": false
        }
      ]
    },
    {
      "number": "158",
      "description": "According to the global symbol table shown here, what is the resolved value for a reference to &&teach&crs?",
      "explanation": "You can use multiple ampersands to delay the resolution of a macro variable reference. You can also combine macro variable references in order to create new tokens. In this example, the reference &&teach&crs resolves to &teach3 on the first scan. On the next scan, &teach3 resolves to Forest, Mr. Peter.",
      "options": [
        {
          "tag": "A",
          "description": "A. &TEACH3",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. TEACH3",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. Forest, Mr. Peter",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. none of the above",
          "correct": false
        }
      ]
    },
    {
      "number": "159",
      "description": "Which of the following statements correctly creates a DATA step variable named Price and assigns to it the value of the macro variable daily_fee during DATA step execution?",
      "explanation": "You can use the SYMGET function in an assignment statement to obtain the current value of a macro variable and to assign that value to a DATA step variable. The SYMGET function enables you to obtain the value of a macro variable during execution of a DATA step, a PROC SQL step, or an SCL program.",
      "options": [
        {
          "tag": "A",
          "description": "A. price=&daily_fee;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. price=symget(daily_fee);",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. price=symget(&daily_fee);",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. price=symget(\"daily_fee\");",
          "correct": true
        }
      ]
    },
    {
      "number": "160",
      "description": "Which of the following is false?",
      "explanation": "The SYMPUT routine can be used in either the DATA step or in an SCL program. In the DATA step, the SYMPUT routine will perform automatic conversion on numeric values that you attempt to assign as values for macro variables, using the BEST12. format. In an SCL program, you should use the SYMPUTN routine if you want to assign a numeric value as a value for a macro variable. In a PROC SQL step, you need to use the INPUT function in order to convert macro variable values to numeric before you compare them to other numeric values.",
      "options": [
        {
          "tag": "A",
          "description": "A. The SYMPUT routine can be used to create a macro variable during execution of the DATA step or during execution of an SCL program.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. In the DATA step, the SYMPUT routine automatically converts to a character value any numeric value that you attempt to assign as the value of a macro variable.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. PROC SQL automatically converts to a numeric value any macro variable value that you attempt to compare to a numeric value.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. In an SCL program, the SYMPUTN routine can be used to assign a numeric value to a macro variable.",
          "correct": false
        }
      ]
    },
    {
      "number": "161",
      "description": "Which of the following is false?",
      "explanation": "A macro definition must begin with a %MACRO statement and must end with a %MEND statement. The macro definition can include macro language statements as well as SAS language statements. When the macro is compiled, macro language statements are checked for syntax errors. The compiled macro is stored in a temporary SAS catalog by default.",
      "options": [
        {
          "tag": "A",
          "description": "A. A %MACRO statement must always be paired with a %MEND statement.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. A macro definition can include macro variable references, but it cannot include SAS language statements.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. Only macro language statements are checked for syntax errors when the macro is compiled.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. Compiled macros are stored in a temporary SAS catalog by default.",
          "correct": false
        }
      ]
    },
    {
      "number": "162",
      "description": "Which of the following examples correctly defines a macro named Print that implements parameters named vars and total?",
      "explanation": "To include positional parameters in a macro definition, you list the parameters in parentheses and separate them with commas. When the macro is executed, macro variables will be created in the local symbol table and will have the same names as the parameters. You can then use these macro variables within the macro.",
      "options": [
        {
          "tag": "A",
          "description": "A. %macro print(vars, total);\nproc print data=classes;\nvar vars;\nsum total;\nrun;\n%mend print;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. %macro print('vars', 'total');\nproc print data=classes;\nvar &vars;\nsum &total;\nrun;\n%mend print;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. %macro print(vars, total);\nproc print data=classes;\nvar &vars;\nsum &total;\nrun;\n%mend print;",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. %macro print(vars, total);\nproc print data=classes;\nvar :vars;\nsum :total;\nrun;\n%mend print;",
          "correct": false
        }
      ]
    },
    {
      "number": "163",
      "description": "Which of the following correctly references the macro named Printdsn as shown here:\n\n%macro printdsn(dsn,vars);\n%if &vars= %then %do;\nproc print data=&dsn;\ntitle \"Full Listing of %upcase(&dsn) data set\";\nrun;\n%end;\n%else %do;\nproc print data=&dsn;\nvar &vars;\ntitle \"Listing of %upcase(&dsn) data set\";\nrun;\n%end;\n%mend;",
      "explanation": "To call a macro that includes positional parameters, you precede the macro name with a percent sign. You list the values for the macro variables that are defined by the parameters in parentheses. List values in the same order in which the parameters are listed, and separate them with commas. Remember that a macro call is not a SAS language statement and does not require a semicolon.",
      "options": [
        {
          "tag": "A",
          "description": "A. %printdsn(sasuser.courses, course_title days);",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. %printdsn(dsn=sasuser.courses, vars=course_title days)",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. %printdsn(sasuser.courses, course_title days)",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. %printdsn(sasuser.courses, course_title, days)",
          "correct": false
        }
      ]
    },
    {
      "number": "164",
      "description": "If you use a mixed parameter list in your macro program definition, which of the following is false?",
      "explanation": "In a mixed parameter list, positional parameters must be listed before any keyword parameters. Both positional and keyword parameters create macro variables in the local symbol table. To assign a null value to a keyword parameter, you list the parameter without a value in the macro call.",
      "options": [
        {
          "tag": "A",
          "description": "A. You must list positional parameters before any keyword parameters.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. Values for both positional and keyword parameters are stored in a local symbol table.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. Default values for keyword parameters are the values that are assigned in the macro definition, whereas positional parameters have a default value of null.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. You can assign a null value to a keyword parameter in a call to the macro by omitting the parameter from the call.",
          "correct": true
        }
      ]
    },
    {
      "number": "165",
      "description": "Which of the following is false?",
      "explanation": "When you submit a macro definition, the macro is compiled and is stored in a SAS catalog. Then when you call the macro, the macro is executed. The macro is available for execution anytime throughout the current SAS session.",
      "options": [
        {
          "tag": "A",
          "description": "A. A macro program is compiled when you submit the macro definition.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. A macro program is executed when you call it (%macro-name).",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. A macro program is stored in a SAS catalog entry only after it is executed.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. A macro program is available for execution throughout the SAS session in which it is compiled.",
          "correct": false
        }
      ]
    },
    {
      "number": "166",
      "description": "When you use an %IF-%THEN statement in your macro program,",
      "explanation": "You can use %IF-%THEN statements to conditionally process code. Within a %IF-%THEN statement, you must use %DO and %END statements to enclose multiple statements. %IF-%THEN statements are similar to IF THEN statements in the DATA step, but they are part of the macro language.",
      "options": [
        {
          "tag": "A",
          "description": "A. you must place %DO and %END statements around code that describes the conditional action, if that code contains multiple statements.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. the %ELSE statement is optional.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. you cannot refer to DATA step variables in the logical expression of the %IF statement.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. all of the above.",
          "correct": true
        }
      ]
    },
    {
      "number": "167",
      "description": "Which of the following can be placed onto the input stack?",
      "explanation": "By using %IF-%THEN statements, you can place whole steps, individual statements, or parts of statements onto the input stack.",
      "options": [
        {
          "tag": "A",
          "description": "A. only whole steps.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. only whole steps or whole statements.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. only whole statements or pieces of text within a statement.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. whole steps, whole statements, or pieces of text within statements.",
          "correct": true
        }
      ]
    },
    {
      "number": "168",
      "description": "Which of the following creates a macro variable named class in a local symbol table?",
      "explanation": "There are several ways to create macro variables in the local symbol table. Macro variables that are created by parameters in a macro definition or by a %LOCAL statement are always created in the local table. Macro variables that are created by a %LET statement or by the SYMPUT routine inside a macro definition might be created in the local table as well.",
      "options": [
        {
          "tag": "A",
          "description": "A. data _null_;\nset sasuser.courses;\n%let class=course_title;\nrun;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. data _null_;\nset sasuser.courses;\ncall symput('class', course_title);\nrun;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. %macro sample(dsn);\n%local class;\n%let class=course_title;\ndata_null_;\nset &dsn;\nrun;\n%mend;",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. %global class;\n%macro sample(dsn);\n%let class=course_title;\ndata _null_;\nset &dsn;\nrun;\n%mend;",
          "correct": false
        }
      ]
    },
    {
      "number": "169",
      "description": "Which of the following examples correctly defines the macro program Hex?",
      "explanation": "To define macros with %DO loops you use a %DO statement and a %END statement. Be sure to precede all keywords in the statements with percent signs since the %DO and %END statements are macro language statements. Also, be sure to end these statements with semicolons. Answer: D When you submit a call to a compiled macro, the macro is executed. Specifically, the macro processor executes compiled macro language statements first. When any SAS language statements are encountered, the macro processor places these statements onto the input stack and pauses while they are passed to the compiler and then executed. Then the macro processor continues to repeat these steps until the %MEND statement is reached.",
      "options": [
        {
          "tag": "A",
          "description": "A. %macro hex(start=1, stop=10, incr=1);\n%local i;\ndata _null_;\n%do i=&start to &stop by &incr;\nvalue=&i;\nput \"Hexadecimal form of &i is \" value hex6.;\n%end;\nrun;\n%mend hex;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. %macro hex(start=1, stop=10, incr=1);\n%local i;\ndata _null_;\n%do i=&start %to &stop %by &incr;\nvalue=&i;\nput \"Hexadecimal form of &i is \" value hex6.;\n%end;\nrun;\n%mend hex;",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. %macro hex(start=1, stop=10, incr=1);\n%local i;\ndata _null_;\n%do i=&start to &stop by &incr;\nvalue=&i;\nput \"Hexadecimal form of &i is \" value hex6.;\nrun;\n%mend hex;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. %macro hex(start=1, stop=10, incr=1);\n%local i;\ndata _null_;\n%do i=&start to &stop by &incr;\nvalue=&i;\nput \"Hexadecimal form of &i is \" value hex6.;\n%end\nrun;\n%mend hex;",
          "correct": false
        }
      ]
    },
    {
      "number": "170",
      "description": "The %INCLUDE statement",
      "explanation": "The %INCLUDE statement can be used to insert the contents of an external file into a SAS program. If a macro definition is stored in an external file, the %INCLUDE statement causes the macro definition to be compiled when it is inserted into the SAS program. The contents of the macro definition will be written to the SAS log only if the SOURCE2 option is specified.",
      "options": [
        {
          "tag": "A",
          "description": "A. can be used to insert the contents of an external file into a program.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. can cause a macro definition that is stored in an external file to be compiled when the contents of that file are inserted into a program and submitted.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. can be specified with the SOURCE2 option in order to write the contents of the external file that is inserted into a program to the SAS log.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. all of the above",
          "correct": true
        }
      ]
    },
    {
      "number": "171",
      "description": "If you store a macro definition in a SAS catalog SOURCE entry",
      "explanation": "When a macro definition is stored as a catalog SOURCE entry, you must compile it before you can call it from a SAS program. You compile a macro that is stored as a catalog SOURCE entry by using the CATALOG access method. This creates a session-compiled macro that will be deleted at the end of the SAS session. The PROC CATALOG statement enables you to view a list of the contents of a SAS catalog.",
      "options": [
        {
          "tag": "A",
          "description": "A. the macro definition can be submitted for compilation by using the FILENAME and %INCLUDE statements.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. you can use the PROC CATALOG statement to compile the macro.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. the SOURCE entry is deleted at the end of the session.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. you do not need to compile the macro before you invoke it in a program.",
          "correct": false
        }
      ]
    },
    {
      "number": "172",
      "description": "Which of the following programs correctly sets the appropriate system options and calls the macro Prtlast? Assume that Prtlast is stored in an autocall library as a text file and that it has not been compiled during the current SAS session.",
      "explanation": "To call a macro that is stored in an autocall library, you must specify both the MAUTOSOURCE system options and the SASAUTOS= system option. The SASAUTOS= system option can be set to include multiple pathnames or filerefs. Once these two system options are set, you can call the macro by preceding the macro name with a percent sign.",
      "options": [
        {
          "tag": "A",
          "description": "A. libname mylib 'c:\\mylib';\nfilename macsrc 'mylib.macsrc';\noptions mautosource sasautos=(macsrc, sasautos);\n%prtlast",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. libname mylib 'c:\\mylib';\nfilename macsrc catalog 'mylib.macsrc';\n%prtlast",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. filename mylib 'c:\\mylib';\noptions mautosource sasautos=(sasautos,mylib);\n%prtlast",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. libname mylib 'c:\\mylib';\noptions mautosource sasautos=mylib;\n%prtlast",
          "correct": false
        }
      ]
    },
    {
      "number": "173",
      "description": "If you use the Stored Compiled Macro Facility,",
      "explanation": "The Stored Compiled Macro Facility enables you to store compiled macros permanently so that you can reuse them in later SAS sessions without compiling them again. Compiled macros must be stored in a catalog named Sasmacr, and both the MSTORED system option and the SASMSTORE= system option must be specified.",
      "options": [
        {
          "tag": "A",
          "description": "A. the macro processor does not compile a macro every time it is used.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. the only compiled macros that the Stored Compiled Macro Facility can access are those that are stored in the Sasmacr catalog.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. you need to specify the MSTORED and SASMSTORE= system options.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. all of the above",
          "correct": true
        }
      ]
    },
    {
      "number": "174",
      "description": "Which of the following correctly creates a permanently stored compiled macro?",
      "explanation": "In order to create a permanently stored compiled macro, you must specify the MSTORED system option. The SASMSTORE= system option must be specified to point to the library in which you want your macros to be stored. You must also use the STORE option in the %MACRO statement.",
      "options": [
        {
          "tag": "A",
          "description": "A. libname macrolib 'c:\\mylib';\noptions sasmstore;\n%macro prtlast; / store\nproc print data=&syslast (obs=5);\ntitle \"Listing of &syslast data set\";\nrun;\n%mend;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. libname macrolib 'c:\\mylib';\noptions mstored sasmstore=macrolib;\n%macro prtlast / store;\nproc print data=&syslast (obs=5);\ntitle \"Listing of &syslast data set\";\nrun;\n%mend;",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. libname macrolib 'c:\\mylib';\noptions mstored sasmstore=macrolib;\n%macro prtlast;\nproc print data=&syslast (obs=5);\ntitle \"Listing of &syslast data set\";\nrun;\n%mend;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. libname macrolib 'c:\\mylib';\n%macro prtlast / store;\nproc print data=&syslast (obs=5);\ntitle \"Listing of &syslast data set\";\nrun;\n%mend;",
          "correct": false
        }
      ]
    },
    {
      "number": "175",
      "description": "When you submit the following code, what happens?\n\n%macro prtlast;\nproc print data=&syslast (obs=5);\ntitle \"Listing of &syslast data set\";\nrun;\n%mend;",
      "explanation": "When you submit a macro definition, SAS creates a session-compiled macro and stores it in the temporary SAS catalog Work.Sasmacr. This macro will be deleted at the end of the SAS session.",
      "options": [
        {
          "tag": "A",
          "description": "A. A session-compiled macro named Prtlast is stored in Work.Sasmacr.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. A macro named Prtlast is stored in the autocall library.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. The Prtlast macro is stored as a stored compiled macro.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. The Prtlast macro is stored as a SOURCE entry in a permanent SAS catalog",
          "correct": false
        }
      ]
    },
    {
      "number": "176",
      "description": "Why would you want to store your macros in external files?",
      "explanation": "If you store your macro definitions in external files, you can easily share these files with others. Also, you can edit a macro definition that is stored in an external file with any text editor, and you can reuse the macro in other SAS sessions.",
      "options": [
        {
          "tag": "A",
          "description": "A. You could easily share your macros with others.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. You could edit your macros with any text editor.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. Your macros would be available for use in later SAS sessions.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. all of the above",
          "correct": true
        }
      ]
    },
    {
      "number": "177",
      "description": "What does the following PROC CATALOG step do?\n\nproc catalog cat=mylib.sasmacr;\ncontents;\nquit;",
      "explanation": "The PROC CATALOG step enables you to view a list of the contents of a SAS catalog. This might be especially useful if you store your macro definitions as SOURCE entries in permanent SAS catalogs. You might also use the PROC CATALOG step to see a list of the session-compiled macros that are stored in Work.Sasmacr.",
      "options": [
        {
          "tag": "A",
          "description": "A. Copy the contents of the Sasmacr catalog to a temporary data set.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. List the contents of the Sasmacr catalog as output.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. Copy the contents of the output window to the Sasmacr catalog.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. none of the above",
          "correct": false
        }
      ]
    },
    {
      "number": "178",
      "description": "Which of the following is not true about stored compiled macros?",
      "explanation": "In order to use the Stored Compiled Macro Facility, you need to specify the MSTORED and SASMSTORE= system options. The Stored Compiled Macro Facility saves the compiled macro in a permanent SAS catalog, but it does not save the macro definition. You cannot move a compiled macro across operating systems. Since you cannot re-create the macro definition from a compiled macro, it is a good idea to save your source program permanently as well.",
      "options": [
        {
          "tag": "A",
          "description": "A. Because these stored macros are compiled, you should save and maintain the source for the macro definitions in a different location.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. The Stored Compiled Macro Facility compiles and saves compiled macros in a permanent catalog, in a library that you specify.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. You do not need to specify any system options in order to use the Stored Compiled Macro Facility.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. You cannot move a stored compiled macro to another operating system.",
          "correct": false
        }
      ]
    },
    {
      "number": "179",
      "description": "Which of the following is not true?",
      "explanation": "The autocall macro facility stores macro definitions  not compiled macros  permanently. The first time an autocall macro is called during a SAS session, the macro is compiled and a session-compiled macro is created in Work.Sasmacr. You can have multiple autocall libraries that are concatenated, and you can use the autocall facility in conjunction with the Stored Compiled Macro Facility.",
      "options": [
        {
          "tag": "A",
          "description": "A. The autocall macro facility stores compiled SAS macros in a collection of external files called an autocall library.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. Autocall libraries can be concatenated together.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. One disadvantage of the autocall facility is that the first time you call an autocall macro in a SAS session, the macro processor must use system resources to compile it.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. The autocall facility can be used in conjunction with the Stored Compiled Macro Facility.",
          "correct": false
        }
      ]
    },
    {
      "number": "180",
      "description": "Which statement is true about an index?",
      "explanation": "An index is a separate file from a data set that contains information about observations within the data set. Specifically, an index contains value/identifier pairs that indicate the location of observations within the data set and the value of one or more key variables in that observation.",
      "options": [
        {
          "tag": "A",
          "description": "A. It is an optional file that is associated with a data set.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. It provides direct access to specific observations of a data set, based on the value of one or more key variables.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. It can be classified as simple or composite, either of which can consist of unique values.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. All of the above.",
          "correct": true
        }
      ]
    },
    {
      "number": "181",
      "description": "Which of the following correctly creates a data set named Flights from the Sasuser.Revenue data set, creates a composite index named Fromto that is based on the values of Origin and Dest, and prints informational messages about the index to the SAS log?",
      "explanation": "To create an index at the same time that you create a data set, you use the INDEX= option in the DATA statement. You must assign a unique name to a composite index, while a simple index is automatically assigned the name of the key variable as its name. You can set the value of the MSGLEVEL= system option to I in order to see messages about indexes in the SAS log.",
      "options": [
        {
          "tag": "A",
          "description": "A. options msglevel=i;\ndata flights index=(Fromto=origin dest);\nset sasuser.revenue;\nrun;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. options msglevel=n;\ndata flights (index=(Fromto=origin dest));\nset sasuser.revenue;\nrun;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. options msglevel=i;\ndata flights (index=(Fromto=(origin dest)));\nset sasuser.revenue;\nrun;",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. options msglevel=n;\ndata flights (index=Fromto);\nset sasuser.revenue;\nrun;",
          "correct": false
        }
      ]
    },
    {
      "number": "182",
      "description": "Which of the following is true?",
      "explanation": "For many maintenance tasks that you perform on a data set, SAS automatically performs corresponding tasks to the index file. For example, if you delete a data set, the index file is deleted as well. If you rename a data set with the CHANGE statement in the DATASETS procedure, SAS automatically renames the index file. If you copy a data set to a new location with the COPY statement in the DATASETS procedure, SAS automatically reconstructs the index file in the new location.",
      "options": [
        {
          "tag": "A",
          "description": "A. When you add observations to a data set, the index or indexes are automatically updated with additional value/identifier pairs.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. When you rename a variable that is used as the key variable in a simple index, you must re-create the index.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. When you delete a data set, the index file remains until you delete it as well.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. When you copy a data set with the COPY statement, you must also copy the index file in another step.",
          "correct": false
        }
      ]
    },
    {
      "number": "183",
      "description": "To create an index on an existing data set, you use which of the following?",
      "explanation": "You can use the DATASETS procedure or the SQL procedure to create or delete an index from an existing data set. You can also rebuild the index with a DATA step and use the INDEX= option to create an index on the rebuilt data set. However, rebuilding a data set uses more system resources than adding an index to an existing data set with either the DATASETS or the SQL procedure.",
      "options": [
        {
          "tag": "A",
          "description": "A. PROC DATASETS",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. PROC SQL",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. the DATA step with the INDEX= option, to rebuild the data set",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. any of the above",
          "correct": true
        }
      ]
    },
    {
      "number": "184",
      "description": "Which of the following correctly creates a simple index named Origin on the Revenue data set?",
      "explanation": "You use the CREATE INDEX statement of the SQL procedure to create an index on an existing data set. In the SQL procedure, you must name the index in the CREATE INDEX statement; for a simple index, the index name must match the name of the key variable.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\ncreate index origin on revenue(origin);\nquit;",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. proc sql;\nmodify revenue;\nindex=origin;\nquit;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql data=revenue;\ncreate index origin;\nquit;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\nindex=origin on revenue;\nquit;",
          "correct": false
        }
      ]
    },
    {
      "number": "185",
      "description": "To view a list of the indexes that are associated with a data set, you use which of the following?",
      "explanation": "You can use either the CONTENTS procedure or the CONTENTS statement in the DATASETS procedure to generate a list of information about a data set, including a list of existing indexes. All indexes for a data set are stored in a single file that is separate from but has the same name as the data set.",
      "options": [
        {
          "tag": "A",
          "description": "A. PROC COPY or the COPY statement in PROC DATASETS",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. PROC CONTENTS or the CONTENTS statement in PROC DATASETS",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. the MSGLEVEL= system option and a PROC PRINT step",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. any of the above",
          "correct": false
        }
      ]
    },
    {
      "number": "186",
      "description": "When you submit a call to a compiled macro, what happens?",
      "explanation": "An index can improve the efficiency with which SAS is able to access certain observations in a data set. However, an index is not always useful. SAS will not use an index to process subsetting IF statements, or other statements that SAS determines might be more efficiently processed without an index.\n",
      "options": [
        {
          "tag": "A",
          "description": "A. First, the macro processor checks all macro programming statements in the macro for syntax errors.\nThen the macro processor executes all statements in the macro.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. The macro processor executes compiled macro programming statements.\nThen any SAS programming language statements are executed by the macro processor.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. First, all compiled macro programming statements are executed by the macro processor.\nAfter all macro statements have been processed, any SAS language statements are passed back to the input stack in order to be passed to the compiler and then executed.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. The macro processor executes compiled macro statements.\nIf any SAS language statements are encountered, they are passed back to the input stack.\nThe macro processor pauses while those statements are passed to the compiler and then executed.\nThen the macro processor continues to repeat these steps until it reaches the %MEND statement.",
          "correct": false
        }
      ]
    },
    {
      "number": "187",
      "description": "Which of the following statements associates the fileref OnSale with the raw data files London.dat, Paris.dat, and Zurich.dat? The files are stored in the C:\\Routes\\New directory in the Windows operating environment.",
      "explanation": "When a FILENAME statement is used to assign a fileref to multiple raw data files, the list of files must be enclosed in a single set of parentheses. Each filename specified must be enclosed in quotation marks.",
      "options": [
        {
          "tag": "A",
          "description": "A. filename onsale (c:\\routes\\new\\london.dat,\nc:\\routes\\new\\paris.dat,\nc:\\routes\\new\\zurich.dat);",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. filename onsale 'c:\\routes\\new\\london.dat'\n'c:\\routes\\new\\paris.dat'\n'c:\\routes\\new\\zurich.dat';",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. filename onsale ('c:\\routes\\new\\london.dat'\n'c:\\routes\\new\\paris.dat'\n'c:\\routes\\new\\zurich.dat');",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. filename onsale 'c:\\routes\\new\\london.dat\nc:\\routes\\new\\paris.dat\nc:\\routes\\new\\zurich.dat';",
          "correct": false
        }
      ]
    },
    {
      "number": "188",
      "description": "Which of the following statements is true?",
      "explanation": "The FILEVAR= option enables you to dynamically change the currently opened input file to a new input file. The FILEVAR= variable must contain a character string that is a physical filename. Like automatic variables, the FILEVAR= variable is not written to the data set.",
      "options": [
        {
          "tag": "A",
          "description": "A. The FILEVAR= option can be used to dynamically change the currently opened input file to a new physical file.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. The FILEVAR= variable is not written to the data set.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. The FILEVAR= variable must contain a character string that is a physical filename.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. all of the above",
          "correct": true
        }
      ]
    },
    {
      "number": "189",
      "description": "Given the following program, which table correctly shows the corresponding values of the variables Month and Readfile?\n\ndata work.revenue;\ndo month = 8, 9, 10;\nreadfile=compress(\"c:\\data\\month\"\n!!put(month,2.)!!\".dat\");\ndo until (lastobs);\ninfile temp filevar=readfile\nend=lastobs;\ninput Date : date7. Location $\nSales : dollar10.;\noutput;\nend;\nend;\nstop;\nrun;",
      "explanation": "The DO statement creates the index variable x and assigns it the values of 8, 9, and 10. The assignment statement assigns the name of a raw data file to Readfile using the current value of x and the PUT function, which concatenates the values of x with the text strings c:\\data\\month and .dat. The COMPRESS function removes blank spaces from the values of Readfile.",
      "options": [
        {
          "tag": "A",
          "description": "A. When x=      readfile=\n8               month8.dat\n9               month9.dat\n10              month10.dat",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. When x=      readfile=\n8\t\t        c:\\data\\month8.dat\n9\t\t        c:\\data\\month9.dat\n10\t\t        c:\\data\\month10.dat",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. When x=\t\treadfile=\n8\t\t        c:\\data\\month 8.dat\n9\t\t        c:\\data\\month 9.dat\n10\t\t        c:\\data\\month10.dat",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. When x=\t\treadfile=\n8\t\t        month8\n9\t\t        month9\n10\t\t        month10",
          "correct": false
        }
      ]
    },
    {
      "number": "190",
      "description": "If the current date is March 30, 2003, which table correctly shows the corresponding values of the variables y1, y2, y3, and Nextfile?\n\ndata work.quarter (drop=monthnum midmon lastmon);\ny3=year(today());\ny2=y3-1;\ny1=y3-2;\ndo i = y3, y2, y1;\nnextfile=\"c:\\data\\Y\"!!put(i,4.)!!\".dat\";\ndo until (lastobs);\ninfile temp filevar=nextfile\nend=lastobs;\ninput Flight $ Origin $ Dest $\nDate : date9.;\noutput;\nend;\nend;\nstop;\nrun;",
      "explanation": "The TODAY function returns the current date from the system clock as a SAS date value. The year number is then extracted from the current date using the YEAR function. The value of the current year, 2003, is assigned to y3. The year values 2002 and 2001 are assigned to y2 and y1, respectively. The PUT function concatenates the text string c:\\data\\Y with the year values and the text string .dat.",
      "options": [
        {
          "tag": "A",
          "description": "A. When i=\t\tNextfile=\ny1\t\tc:\\data\\Y2001.dat\ny2\t\tc:\\data\\Y2002.dat\ny3\t\tc:\\data\\Y2003.dat",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. When i=\t\tNextfile=\ny1\t\tY2001.dat\ny2\t\tY2002.dat\ny3\t\tY2003.dat",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. When i=\t\tNextfile=\ny1      \t\tc:\\data\\Y2003.dat\ny2\t\t        c:\\data\\Y2002.dat\ny3\t\t        c:\\data\\Y2001.dat",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. When i=\t\tNextfile=\ny1\t\t        c:\\data\\Y3.dat\ny2\t\t        c:\\data\\Y2.dat\ny3\t\t        c:\\data\\Y1.dat",
          "correct": false
        }
      ]
    },
    {
      "number": "191",
      "description": "What happens when SAS processes the last data record in an input file?",
      "explanation": "The END= option names a variable whose value is controlled by SAS. The value of the variable is 1 when you read the last record in an input file. Otherwise it is 0. You can test the value of the  END= variable to determine if the DATA step should continue processing. Like automatic variables, the END= variable is not written to the SAS data set.",
      "options": [
        {
          "tag": "A",
          "description": "A. The END= variable is set to 1.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. The END= variable is set to 0.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. The END= variable is set to the number of records in the input file.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. The END= variable is written to the SAS data set.",
          "correct": false
        }
      ]
    },
    {
      "number": "192",
      "description": "Which program appends Work.London to Work.Flights?",
      "explanation": "PROC APPEND uses the BASE= and DATA= arguments. BASE=SAS-data-set names the data set to which you want to add observations. DATA=SAS-data-set names the SAS data set containing observations that you want to append to the end of the BASE= data set.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc append base=work.london\ndata=work.flights;\nrun;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc append data=work.london\nbase=work.flights;\nrun;",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. proc append data=work.london work.flights;\nrun;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc append data=work.flights work.london;\nrun;",
          "correct": false
        }
      ]
    },
    {
      "number": "193",
      "description": "What happens when the following program is submitted?\n\nproc append base=staff.marketing\ndata=staff.sales force;\nrun;\nData Set Description for Staff.Marketing\nVariable        Type        Length\nLastName        char        12\nFirstName       char        10\nEmpID           char        5\nOffice          char        4\nPhone           char        12\n\nData Set Description for Staff.Sales\nVariable        Type        Length\nLastName        char        20\nFirstName       char        10\nEmpID           char        5\nOffice          char        4\nPhone           char        12",
      "explanation": "If a DATA= data set contains variables that are longer than the corresponding variables in the BASE= data set, the FORCE option must be used with PROC APPEND. Using the FORCE option enables you to append the data sets. However, some of the variable values may be truncated in the observations that are read in from the DATA= data set.\n",
      "options": [
        {
          "tag": "A",
          "description": "A. The length of LastName is converted to 20 in Staff.Marketing.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. LastName is dropped from Staff.Marketing.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. Missing values are assigned to LastName observations that are read in from Staff.Sales.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. Some of the values of LastName might be truncated in the observations that are read in from Staff.Sales.",
          "correct": true
        }
      ]
    },
    {
      "number": "194",
      "description": "Which program appends Work.April to Work.Y2003?\n\nData Set Description for Work.Y2003\nVariable        Type      Length\nFlightNum       Num          8\nFirstClass      Num          8\nBusinessClass   Num          8\nCoach           Num          8\n\nData Set Description for Work.April\nVariable        Type      Length\nFlightNum       Char        4\nFirstClass      Num         8\nBusinessClass   Num         8\nCoach           Num         8",
      "explanation": "You must use the FORCE option with PROC APPEND when the DATA= data set contains a variable that does not have the same type as the corresponding variable in the BASE= data set.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc append base=work.y2003\ndata=work.april;\nrun;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc append base=work.april\ndata=work.y2003 force;\nrun;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc append base=work.y2003\ndata=work.april force;\nrun;",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. proc append base=work.april\ndata=work.y2003;\nrun;",
          "correct": false
        }
      ]
    },
    {
      "number": "195",
      "description": "What happens when the SAS data set Work.NewHires is appended to the SAS data set Work.Employees using PROC APPEND?\nData Set Description for Work.Employees\nVariable    Type    Length\nDivision    num     8\nEmpID       num     8\nName        char    20\nRoom        char    5\nExtension   num     8\n\nData Set Description for Work.NewHires\nVariable    Type    Length\nDivision    num     8\nEmpID       num     8\nName        char    20\nExtension   num     8",
      "explanation": "When the BASE= data set contains more variables than the DATA= data set, missing values for the additional variables are assigned to the observations that are read in from the DATA= data set.\n",
      "options": [
        {
          "tag": "A",
          "description": "A. Missing values are assigned to Room for the observations that are read in from Work.NewHires.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. Missing values are assigned to Room for all of the observations in Work.Employees.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. Room is dropped from Work.Employees.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. The values of Name are truncated in the observations that are read in from Work.NewHires.",
          "correct": false
        }
      ]
    },
    {
      "number": "196",
      "description": "You do not need to use the FORCE option with PROC APPEND when the following is true:",
      "explanation": "The FORCE option does not need to be used if the BASE= data set contains variables that are not in the DATA= data set. The FORCE option must be used if\nthe DATA= data set contains variables that are not in the BASE= data set\nthe variables in the DATA= data set are longer than the corresponding variables in the BASE= data set\nthe variables in the DATA= data set have a different type than the corresponding variables in the BASE= data set.\n",
      "options": [
        {
          "tag": "A",
          "description": "A. the DATA= data set contains variables that are not in the BASE= data set.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. the BASE= data set contains variables that are not in the DATA= data set.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. the variables in the DATA= data set are longer than the corresponding variables in the BASE= data set.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. the variables in the DATA= data set have a different type than the corresponding variables in the BASE= data set.",
          "correct": false
        }
      ]
    },
    {
      "number": "197",
      "description": "According to the data set descriptions below, which of the variables that are listed qualify as BY variables for a DATA step match-merge?\n\nVariable    Type\tLength  Description\nCode\t\tChar\t5\t    Department Code\nTotemps\t\tNum\t    3\t    Total number of employees\nRegion\t\tChar\t5\t    Location of department\nManager\t\tNum\t    4       Employee ID number\n\nVariable    Type\tLength\tDescription\nIDnum\t\tNum\t    5\t    Employee ID number\nName\t\tChar\t3\t    Employee Name\nDevision\tChar\t5\t    Division Abbreviation\nhiredate\tNum\t    4\t    Date of hire\nSupervisor\tChar\t20\t    Name of supervisor",
      "explanation": "Remember that common variables might not have the same names. Manager and IDnum are the only two variables listed that match according to type and description. You can use the RENAME= option to rename one of these variables so that they can be used as BY variables in the MERGE statement of the DATA step.",
      "options": [
        {
          "tag": "A",
          "description": "A. Code and IDnum",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. Manager and Supervisor",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. Manager and IDnum",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. There are no variables that are common to both of these data sets.",
          "correct": false
        }
      ]
    },
    {
      "number": "198",
      "description": "Suppose you want to merge Dataset1, Dataset2, and Dataset3. Also suppose that Dataset1 and Dataset2 have the common variable Startdate, that Dataset2 and Dataset3 have the common variable Instructor, and that these data sets have no other common variables. How can you use a DATA step to merge these three data sets into one new data set?",
      "explanation": "In order to merge multiple data sets in a DATA step, the data sets must have a common variable. However, if there are variables that are common to at least two of the input data sets, and if each input data set contains at least one of these variables, then you can use subsequent DATA steps to merge the data sets. You can also use a PROC SQL step to merge data sets that do not have common variables.\n",
      "options": [
        {
          "tag": "A",
          "description": "A. You use a MERGE statement in one DATA step to merge Dataset1, Dataset2, and Dataset3 by Startdate and Instructor.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. You sort Dataset1 and Dataset2 by Startdate and merge them into a temporary data set in a DATA step. Then you sort the temporary data set and Dataset3 by Instructor and merge them into a new data set in a DATA step.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. You can merge these data sets only with a PROC SQL step.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. You cannot merge these three data sets at all because they do not have a common variable.",
          "correct": false
        }
      ]
    },
    {
      "number": "199",
      "description": "Which of the following programs correctly creates a table with the results of a PROC SQL inner join matched on the values of empcode?",
      "explanation": "You can use PROC SQL to join data from data sets that do not have a single common variable among them. If you create a new table with the result of an inner join in a PROC SQL step, the resulting data set can be similar or identical to the result of a DATA step match-merge.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sql;\nselect newsals.empcode allemps.lastname\nnewsals.salary contrib.amount\nfrom sasuser.allemps, sasuser.contrib,\nsasuser.newsals\nwhere empcode=allemps.empid\nand empcode=contrib.empid;\nquit;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc sql;\ncreate table usesql as\nselect newsals.empcode allemps.lastname\nnewsals.salsry contrib.amount\nfrom sasuser.allemps, sasuser.contrib,\nsasuser.newsals\nquit;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc sql;\ncreate table usesql as;\nselect newsals.empcode, allemps.lastname,\nnewsals.salary, contrib.amount;\nfrom sasuser.allemps, sasuser.contrib,\nsasuser.newsals;\nwhere empcode=allemps.empid\nand empcode=contrib.empid;\nquit;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc sql;\ncreate table usesql as\nselect newsals.empcode, allemps.lastname,\nnewsals.salary, contrib.amount\nfrom sasuser.allemps, sasuser.contrib,\nsasuser.newsals\nwhere empcode=allemps.empid\nand empcode=contrib.empid;\nquit;",
          "correct": true
        }
      ]
    },
    {
      "number": "200",
      "description": "To process a default DATA step match-merge, SAS first reads the descriptor portion of each input data set to create the PDV and the descriptor portion of the new data set. Which of the following accurately describes the rest of this process?",
      "explanation": "In a DATA step match-merge, SAS reads observations from the input data sets sequentially and match-merges them with observations from other input data sets. Combined observations are created when SAS reads observations from all input data sets into the PDV. These observations, as well as any observations that contain missing or nonmatched values, are then written to the new data set. A PROC SQL join creates a Cartesian product of matches and then eliminates nonmatching data.",
      "options": [
        {
          "tag": "A",
          "description": "A. Next, SAS sequentially match-merges observations reading them into the PDV, and then writes them to the new data set. When the BY value changes in all the input data sets, the PDV is initialized to missing. Missing values for variables, as well as missing values that result from unmatched observations, are written to the new data set.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. Next, SAS sequentially match-merges observations reading them into the PDV, and then writes them to the new data set. After each DATA step iteration, the PDV is initialized to missing. Missing values for variables, as well as missing values that result from unmatched observations, are omitted from the new data set.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. Next, SAS creates a Cartesian product of all possible combinations of observations, writes them to the PDV, and then to the new data set. Then SAS goes through the new data set and eliminates all observations that do not have matching values of the BY variable.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. Next, SAS creates a Cartesian product of all possible combinations of observations, writes them to the PDV, and then to the new data set. The new data set is then ordered by values of the BY variable.",
          "correct": false
        }
      ]
    },
    {
      "number": "201",
      "description": "Which of the following statements is false about using multiple SET statements in one DATA step?",
      "explanation": "You can use multiple SET statements in one DATA step to combine observations from several data sets. The data sets do not need to have a common variable.",
      "options": [
        {
          "tag": "A",
          "description": "A. You can use multiple SET statements to combine observations from several SAS data sets.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. Processing stops when SAS encounters the end-of-file (EOF) marker on either data set (even if there is more data in the other data set).",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. You can use multiple SET statements in one DATA step only if the data sets in each SET statement have a common variable.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. The variables in the PDV are not reinitialized when a second SET statement is executed.",
          "correct": false
        }
      ]
    },
    {
      "number": "202",
      "description": "Select the program that correctly creates a new data set named Sasuser.Summary that contains one observation with summary data that was created from the Salary variable of the Sasuser.Empdata data set.",
      "explanation": "You can use the MEANS procedure to create a new data set that contains a summary statistic. The NOPRINT option suppresses the default report. The OUTPUT statement routes the results from the MEANS procedure to a new data set. The VAR statement specifies one or more numeric variables from the input data set.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc sum data=sasuser.emdata noprint;\noutput out=sasuser.summary sum=Salarysum;\nrun;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc means data=sasuser.empdata noprint;\nvar salary;\noutput out=sasuser.summary sum=Salarysum;\nrun;",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. proc sum data=sasuser.empdata noprint;\nvar salary;\noutput out=sasuser.summary sum=Salarysum;\nrun;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc means data=sasuser.empdata noprint;\noutput=sasuser.summary sum=Salarysum;\nrun;",
          "correct": false
        }
      ]
    },
    {
      "number": "203",
      "description": "If the value of Cargosum is $1000 at the end of the first iteration of the DATA step shown below, what is the value of Cargosum in the PDV when the DATA step is in its third iteration?\ndata sasuser.percent1;\nif _n_=1 then set sasuser.summary (keep=cargosum);\nset sasuser.monthsum (keep=salemon revcargo);\nPctRev=revcargo/cargosum;\nrun;",
      "explanation": "The _N_ variable records how many times the DATA step has iterated. In the example, _N_ is used to ensure that the first SET statement executes only one time so the one observation is read from Sasuser.Summary, but the end of file marker is not read. Since the values in the PDV are not reinitialized after each DATA step iteration, the value of CARGOSUM is retained throughout DATA step execution. Therefore, if the value of Cargosum is $1000 in the first iteration, it will be $1000 in each subsequent iteration as well.",
      "options": [
        {
          "tag": "A",
          "description": "A. $1000",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. $3000",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. The value is missing.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. The value cannot be determined without seeing the data that is in Sasuser.Summary.",
          "correct": false
        }
      ]
    },
    {
      "number": "204",
      "description": "According to the data set shown, what is the value of Totalrev in the PDV at the end of the fourth iteration of the DATA step?\nObs\tSaleMon\t\tRevCargo\n1\tJAN1997\t\t$520.00\n2\tJAN1998\t\t$230.00\n3\tJAN1999\t\t$350.00\n4\tFEB1997\n\ndata sasuser.percent2(drop=totalrev);\nif _n_=1 then do until(lastobs);\nset sasuser.monthsum2(keep=revcargo)\nend=lastobs;\ntotalrev+revcargo;\nend;\nset sasuser.monthsum2\n(keep=salemon revcargo);\nPctRev=revcargo/totalrev;\nrun;",
      "explanation": "Totalrev is the accumulator variable of the sum statement, which is automatically initialized with a value of 0. If the expression in a sum statement produces a missing value, SAS replaces the missing value with a value of 0. As the DATA step iterates, the sum statement retains the accumulator variable so that it will accumulate a total.",
      "options": [
        {
          "tag": "A",
          "description": "A. The value is missing.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. $350.00",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. $520.00",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. $1100.00",
          "correct": true
        }
      ]
    },
    {
      "number": "205",
      "description": "Which of the following programs correctly uses an index to combine data from two input data sets?",
      "explanation": "You use the KEY= option in a SET statement to cause SAS to use an index to combine data from multiple data sets. When the SET statement with the KEY= option executes, the program data vector must already contain a value for the indexed variable. You cannot use WHERE processing on a data set that has been read with the KEY= option within the same DATA step.",
      "options": [
        {
          "tag": "A",
          "description": "A. data work.profit;\nset sasuser.sale2000(keep=routeid flightid date\nrev1st revbusiness revecon revcargo)\nkey=flightdate;\nset sasuser.dnunder;\nProfit=sum(rev1st, revbusiness, revecon, revcargo,\n-expenses);\nrun;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. data work.profit;\nset sasuser.dnunder;\nset sasuser.sale2000(keep=routeid flightid date\nrev1st revbusiness revecon revcargo)\nkey=flightdate;\nwhere routeid='0000103';\nProfit=sum(rev1st, revbusiness, revecon, revcargo,\n-expenses);\nrun;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. data work.profit;\nset sasuser.dnunder;\nset sasuser.sale2000(keep=routeid flightid date\nrev1st revbusiness revecon revcargo);\nkey=flightdate;\nProfit=sum(rev1st, revbusiness, revecon, revcargo,\n-expenses);\nrun;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. data work.profit;\nset sasuser.dnunder;\nset sasuser.sale2000(keep=routeid flightid date\nrev1st revbusiness revecon revcargo)\nkey=flightdate;\nProfit=sum(rev1st, revbusiness, revecon, revcargo,\n-expenses);\nrun;",
          "correct": true
        }
      ]
    },
    {
      "number": "206",
      "description": "Which of the following statements about the _IORC_ variable is false?",
      "explanation": "When you use the KEY= option, SAS creates an automatic variable named _IORC_, which stands for INPUT/OUTPUT Return Code. If the value of _IORC_ is zero, the index search was successful. The _IORC_ variable is also created automatically when you use a MODIFY statement in a DATA step.",
      "options": [
        {
          "tag": "A",
          "description": "A. It is automatically created when you use either a SET statement with the KEY= option or the MODIFY statement with the KEY= option in a DATA step.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. A value of zero for _IORC_ means that the most recent SET statement with the KEY= option (or MODIFY statement with the KEY= option) did not execute successfully.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. A value of zero for _IORC_ means that the most recent SET statement with the KEY= option (or MODIFY statement with the KEY= option) executed successfully.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. You can use the _IORC_ variable to prevent nonmatching data from being included when you use an index to combine data from multiple data sets",
          "correct": false
        }
      ]
    },
    {
      "number": "207",
      "description": "Which SAS statement correctly specifies the array Sales as illustrated in the following table?\nTable Representation of Sales Array\nm1\tm2\tm3\tm4\nm5\tm6\tm7\tm8\nm9\tm10\tm11\tm12",
      "explanation": "An array is specified using the keyword ARRAY followed by the name of the array and the dimensions of the array. In a two-dimensional array, the two dimensions can be thought of as a table of rows and columns. The first dimension in the ARRAY statement specifies the number of rows. The second dimension specifies the number of columns.",
      "options": [
        {
          "tag": "A",
          "description": "A. array Sales{3,4} m1-m12;",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. array Sales{4,3} m1-m12;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. array {3,4} Sales m1-m12;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. array {4,12} Sales m1-m12;",
          "correct": false
        }
      ]
    },
    {
      "number": "208",
      "description": "Which of the following statements creates temporary array elements?",
      "explanation": "To create temporary array elements, specify the keyword _TEMPORARY_ after the array name and dimension. Remember that if you use an asterisk to count the array elements, you must list the array elements. You cannot use the asterisk and the _TEMPORARY_ keyword together in an ARRAY statement.",
      "options": [
        {
          "tag": "A",
          "description": "A. array new {*} _temporary_;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. array new {6} _temporary_;",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. array new {*} _temporary_ Jan Feb Mar Apr May Jun;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. array _temporary_ new {6} Jan Feb Mar Apr May Jun;",
          "correct": false
        }
      ]
    },
    {
      "number": "209",
      "description": "Which DO statement processes all of the elements in the Yearx array?\narray Yearx{12} Jan--Dec;",
      "explanation": "To process all of the elements in an array, you can use either the DIM function with the array name as the argument or specify the array dimension.",
      "options": [
        {
          "tag": "A",
          "description": "A. do i=1 to dim(yearx);",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. do i=1 to 12;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. do i=Jan to Dec;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. a and b",
          "correct": true
        }
      ]
    },
    {
      "number": "210",
      "description": "Given the following program, what is the value of Points in the fifth observation in the data set Work.Results?\nSAS Data Set Work.Contest\nObs\tNAME\t\tWEEK\tFIFNISH\n1\tTuttle\t\t1       1\n2\tGomez\t\t1       2\n3\tChapamn\t\t1       3\n4\tVenter\t\t1       4\n5\tVandeusen\t2       1\n6\tTuttle\t\t2       2\n7\tVenter\t\t2       3\n8\tGomez\t\t2       4\n\ndata work.results;\narray score{2,4} _temporary_\n(40,50,60,70,40,50,60,70);\nset work.contest;\nPoints=score{week,finish};\nrun;",
      "explanation": "The ARRAY statement creates the two-dimensional array Score and specifies the dimensions of the array: two rows and four columns. The value of Points for each observation is determined by referencing the array based on the values of Week and Finish in the Work.Contest data set. The row number for the array reference is determined by the value of Week. The column number for the array reference is determined by the value of Finish.",
      "options": [
        {
          "tag": "A",
          "description": "A. 40",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. 50",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. 60",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. 70",
          "correct": false
        }
      ]
    },
    {
      "number": "211",
      "description": "Array values should be stored in a SAS data set when which of the following is true?",
      "explanation": "Lookup tables should be stored in a SAS data set when there are too many values to initialize easily in an array, the values change frequently, or the same values are used in many programs.",
      "options": [
        {
          "tag": "A",
          "description": "A. There are too many values to initialize easily in an array.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. The values change frequently.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. The same values are used in many programs.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. All of the above.",
          "correct": true
        }
      ]
    },
    {
      "number": "212",
      "description": "Given the following program, which statement is not true?\n\ndata work.lookup1;\narray Targets{1997:1999,12} _temporary_;\nif _n_=1 then do i= 1 to 3;\nset sasuser.ctargets;\narray Mnth{*} Jan--Dec;\ndo j=1 to dim(mnth);\ntargets{year,j}=mnth{j};\nend;\nend;\nset sasuser.monthsum(keep=salemon revcargo monthno);\nyear=input(substr(salemon,4),4.);\nCtarget=targets{year,monthno};\nrun;",
      "explanation": "The IF-THEN statement specifies that the Targets array is loaded only once, during the first iteration of the DATA step. During the first iteration of the DATA step, the condition _N_=1 is true, so the outer DO loop executes three times; once for each observation in Sasuser.Ctargets. After the third iteration of the DO loop, the pointer drops down to the second SET statement and the values from the first observation in Sasuser.Monthum are read into the program data vector. During the second iteration of the DATA step, the condition _N_=1 is false. So, the DO loop doesn't execute again.\n",
      "options": [
        {
          "tag": "A",
          "description": "A. The IF-THEN statement specifies that the Targets array is loaded once.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. During the first iteration of the DATA step, the outer DO loop executes three times.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. After the first iteration of the DO loop, the pointer drops down to the second SET statement.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. During the second iteration of the DATA step, the condition _N_=1 is false. So, the DO loop does not execute.",
          "correct": false
        }
      ]
    },
    {
      "number": "213",
      "description": "Which SAS system option is used to identify format catalogs to SAS?",
      "explanation": "By default, SAS searches for custom formats in the Work and Library libraries. The FMTSEARCH= system option specifies other catalogs to search when a format is referenced.",
      "options": [
        {
          "tag": "A",
          "description": "A. FMTERR",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. FMTLIB",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. NOFMTERR",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. FMTSEARCH=",
          "correct": true
        }
      ]
    },
    {
      "number": "214",
      "description": "Given the following PROC FORMAT step, how is the value 70 displayed when the AGEGRP. format is applied?\nproc format;\npicture agegrp\n1-<13='00 Youth'\n13-<20='00 Teen'\n20-<70='00 Adult'\n70-high='000 Senior';\nrun;",
      "explanation": "A non-inclusive range is used such that the age at the high end of the range is not included. To create the picture format, three zeros are used to create a position for a three-digit numeric value. Because zero is used as a digit selector rather than a nonzero value, leading zeros are not included in the formatted value.",
      "options": [
        {
          "tag": "A",
          "description": "A. 000 Senior",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. 70 Adult",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. 70 Senior",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. 070 Senior",
          "correct": false
        }
      ]
    },
    {
      "number": "215",
      "description": "When the NOFMTERR system option is in effect, what happens when SAS encounters a format that it cannot locate?",
      "explanation": "By default, FMTERR is in effect so SAS stops processing if it cannot find a format that is referenced. When NOFMTERR is in effect, SAS substitutes the $w. or w. format and continues processing.",
      "options": [
        {
          "tag": "A",
          "description": "A. Creates the format in the default Work.Formats directory and continues processing.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. Substitutes the $w. or w. format and continues processing.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. Stops processing and writes an error message to the log.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. Skips processing at that step and continues with the next step and writes a note to the log.",
          "correct": false
        }
      ]
    },
    {
      "number": "216",
      "description": "Which of the following variables must be in the data set that is specified in the CNTLIN= option?",
      "explanation": "A data set that is used to create a format with the CNTLIN= option must have the variables FmtName, Start, and Label. If a range is specified, it must also include the variable End.",
      "options": [
        {
          "tag": "A",
          "description": "A. End",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. FmtName",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. Value",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. Description",
          "correct": false
        }
      ]
    },
    {
      "number": "217",
      "description": "Given the following code, what option is missing?\n\nproc format;\nvalue times (?)\n'00:00't-'04:59't = 'Red Eye'\n'05:00't-'11:59't = 'Morning'\n'12:00't-'17:59't = 'Afternoon'\n'18:00't-'23:59't = 'Evening'\n'00:00't-'11:59't = 'AM'\n'12:00't-'23:59't = 'PM';\nrun;",
      "explanation": "The format created by this value statement has overlapping ranges, so the MULTILABEL option must be used. A multilabel format can be used by any procedure that supports the MLF option.",
      "options": [
        {
          "tag": "A",
          "description": "A. MULTILABEL",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. MULTIRANGE",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. MLF",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. MULTIFORMAT",
          "correct": false
        }
      ]
    },
    {
      "number": "218",
      "description": "Which PROC FORMAT option is used to create a SAS data set from a format?",
      "explanation": "The CNTLOUT= option is used to create a SAS data set from a format.",
      "options": [
        {
          "tag": "A",
          "description": "A. CNTLIN=",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. LIB=",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. CNTLOUT=",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. FMTLIB",
          "correct": false
        }
      ]
    },
    {
      "number": "219",
      "description": "Given the following OPTIONS statement, in what order will SAS search to find a user-defined format?\noptions fmtsearch=(work abc.newfmt sasuser);",
      "explanation": "SAS will search in the order specified on the FMTSEARCH= option. By default, SAS searches in the Work and Library libraries first unless they are specified on the option. Because Library is not specified here, it is searched after Work.",
      "options": [
        {
          "tag": "A",
          "description": "A. Work.Formats  Abc.Newfmt  Sasuser.Formats  Library.Formats",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. Work.Formats  Library.Formats  Abc.Newfmt  Sasuser.Formats",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. Work.Formats  Abc.Newfmt  Sasuser.Format",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. the default search order",
          "correct": false
        }
      ]
    },
    {
      "number": "220",
      "description": "What option is used with PROC FORMAT to document the formats in a particular format catalog?",
      "explanation": "The FMTLIB keyword is used to document the formats in a catalog. You can use the SELECT and EXCLUDE statements to process specific formats rather than the entire catalog.",
      "options": [
        {
          "tag": "A",
          "description": "A. FMTSEARCH",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. FMTERR",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. CATALOG",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. FMTLIB",
          "correct": true
        }
      ]
    },
    {
      "number": "221",
      "description": "Which set of statements would you add to the PROC CATALOG code to copy the LEVELS. and $PICKS. formats from the Sasuser.Formats catalog to the Work.Formats catalog?\nproc catalog cat=sasuser.formats;\n?\n?\nrun;",
      "explanation": "In the COPY statement, OUT= specifies the catalog to which you want to copy the format catalog entry. In the SELECT statement, you specify the catalog entries by their entire name. Remember that numeric formats are stored with the extension .FORMAT and character formats are stored with the extension .FORMATC.",
      "options": [
        {
          "tag": "A",
          "description": "A. copy out=sasuser.formats;\nselect levels.format $picks.format;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. copy out=work.formats;\nselect levels $picks;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. copy out=work.formats;\nselect levels.format picks.formatc;",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. copy out=work.formats;\nselect levels.format $picks.format;",
          "correct": false
        }
      ]
    },
    {
      "number": "222",
      "description": "Given the following PROC FORMAT step, how is the value 6.1 displayed when the SKICOND format is applied?\nproc format;\nvalue skicond\n0-3='Poor'\n3<-6='Fair'\n6<-9='Good'\n9<-high='Excellent';\nrun;",
      "explanation": "The value 6.1 falls in the range 6<-9, which is labeled 'Good.' The non-inclusive range does not include the value 6, but it does include values above 6.",
      "options": [
        {
          "tag": "A",
          "description": "A. 6.1",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. Fair",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. Good",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. .",
          "correct": false
        }
      ]
    },
    {
      "number": "223",
      "description": "Which type of integrity constraint would you place on the variable StoreID to ensure that there are no missing values and that there are no duplicate values?",
      "explanation": "The PRIMARY KEY integrity constraint includes both the NOT NULL and UNIQUE constraints.",
      "options": [
        {
          "tag": "A",
          "description": "A. UNIQUE",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. CHECK",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. PRIMARY KEY",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. NOT NULL",
          "correct": false
        }
      ]
    },
    {
      "number": "224",
      "description": "Which code creates an audit trail on the SAS data set Reports.Quarter1?",
      "explanation": "To initiate an audit on an existing SAS data set with the DATASETS procedure, you specify the data set in the AUDIT statement, and then you specify the INITIATE statement. You specify the library with the LIB= option.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc datasets nolist;\naudit quarter1;\ninitiate;\nquit;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc datasets lib=reports nolist;\naudit initiate reports.quarter1;\nquit;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc datasets lib=reports nolist;\ninitiate audit quarter1;\nquit;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc datasets lib=reports nolist;\naudit quarter1;\ninitiate;\nquit;",
          "correct": true
        }
      ]
    },
    {
      "number": "225",
      "description": "Which DATA step uses the transaction data set Records.Overnight to update the master data set Records.Snowfall by accumAmt?",
      "explanation": "In the MODIFY statement, you specify the master data set followed by the transaction data set. Then you specify the key variable in the BY statement.",
      "options": [
        {
          "tag": "A",
          "description": "A. data records.snowfall;\nmodify records.snowfall records.overnight\nkey=accumAmt;\nrun;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. data records.snowfall;\nmodify records.overnight records.snowfall;\nby accumAmt;\nrun;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. data records.snowfall;\nmodify records.snowfall records.overnight;\nby accumAmt;\nrun;",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. data records.snowfall;\nmodify records.snowfall records.overnight;\nupdate accumAmt;\nrun;",
          "correct": false
        }
      ]
    },
    {
      "number": "226",
      "description": "The automatic variable _IORC_ is created when you use the MODIFY statement with a BY statement or the KEY= option. How can you use the value of _IORC_?",
      "explanation": "The value of _IORC_ is a numeric return code that indicates the status of the most recently executed I/O operation. Checking the value of this variable allows you to detect abnormal I/O conditions and direct execution in particular ways.",
      "options": [
        {
          "tag": "A",
          "description": "A. to determine whether the index specified on the KEY= option is a valid index",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. to determine the number of observations that were updated in the master data set",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. to determine the status of the I/O operation",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. to determine the number of observations that could not be updated in the master data set",
          "correct": false
        }
      ]
    },
    {
      "number": "227",
      "description": "Which PROC DATASETS step creates an integrity constraint named val_age on the data set Survey to ensure that values of the variable Age are greater than or equal to 18?",
      "explanation": "In the MODIFY statement, you list the SAS data set that you want to modify. Then you use the IC CREATE statement to create the integrity constraint. This integrity constraint is a CHECK constraint with a WHERE clause to specify the condition that the variable values must meet.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc datasets nolist;\nmodify age;\nic create val_age=check(where=(age>=18));\nquit;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc datasets nolist;\nmodify Survey;\nic create val_age=check(age>=18);\nquit;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc datasets nolist;\nmodify survey;\nintegrity constraint\nval_age=check(where=(age>=18));\nquit;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc datasets nolist;\nmodify survey;\nic create val_age=check(where=(age>=18));\nquit;",
          "correct": true
        }
      ]
    },
    {
      "number": "228",
      "description": "Which statement about using the MODIFY statement in a DATA step is true?",
      "explanation": "The MODIFY statement in a DATA step can be used only to modify the values in a data set. It cannot be used to modify the descriptor portion of the data set.",
      "options": [
        {
          "tag": "A",
          "description": "A. MODIFY creates a second copy of the data while variables in the data are being matched with a WHERE clause and then deletes the second copy.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. You cannot modify the descriptor portion of the data set using the MODIFY statement.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. You can use the MODIFY statement to change the name of a variable.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. If the system terminates abnormally while a DATA step that is using the WHERE statement is processing, SAS automatically saves a copy of the unaltered data set.",
          "correct": false
        }
      ]
    },
    {
      "number": "229",
      "description": "Which of the following statements about audit trails is true?",
      "explanation": "Audit trails are used to track changes that are made to a data set in place.",
      "options": [
        {
          "tag": "A",
          "description": "A. They create historical versions of data so that a copy of the data set is saved each time the data is replaced.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. They record information about changes to observations in a data set each time the data set is replaced.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. They record information about changes to observations in a data set each time the data is modified in place.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. The audit trail file has the same name as the SAS data file that it is monitoring, but has #AUDIT at the end of the data set name.",
          "correct": false
        }
      ]
    },
    {
      "number": "230",
      "description": "Which code initiates generation data sets on the existing SAS data set Sasuser.Amounts and specifies that five historical versions are saved in addition to the base version?",
      "explanation": "You use the DATASETS procedure and the MODIFY statement to specify a number of generation data sets for a data set. The GENMAX= option is used to specify the number of versions to save. The number you specify includes the base version.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc datasets lib=sasuser nolist;\nmodify Amounts (genmax=6);\nquit;",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. proc datasets lib=sasuser nolist;\nmodify Amounts (genmax=5);\nquit;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc datasets lib=sasuser nolist;\nmodify Amounts (gennum=6);\nquit;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc datasets lib=sasuser nolist;\nmodify Amounts (gennum=5);\nquit;",
          "correct": false
        }
      ]
    },
    {
      "number": "231",
      "description": "Which statement about using the KEY= option in the MODIFY statement is true?",
      "explanation": "When you use the KEY= option, you must specify the update that you want to make to the data set.",
      "options": [
        {
          "tag": "A",
          "description": "A. SAS locates the variables to update using the index specified in the KEY= option and then automatically overlays nonmissing transaction values as it does when you use the MODIFY or BY statements.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. When you use the KEY= option, you must explicitly state the update that you want to make. SAS does not automatically overlay nonmissing transaction values.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. The KEY= option is used to specify a variable to match for updating observations.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. The index named in the KEY= option must be a simple index.",
          "correct": false
        }
      ]
    },
    {
      "number": "232",
      "description": "Which code deletes all generations of the data set Sasuser.Amounts including the base data set?",
      "explanation": "The keyword ALL is used to indicate that you want to delete all generations of the specified data set, including the base version. The keyword HIST deletes the generation data sets, but saves the base version.\n",
      "options": [
        {
          "tag": "A",
          "description": "A. proc datasets lib=sasuser nolist;\ndelete amounts (gennum=ALL);\nquit;",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. proc datasets lib=sasuser nolist;\ndelete amounts (gennum=HIST);\nquit;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. proc datasets lib=sasuser nolist;\ndelete amounts (gennum=0);\nquit;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc datasets lib=sasuser nolist;\ndelete amounts;\nquit;",
          "correct": false
        }
      ]
    },
    {
      "number": "233",
      "description": "Which of the following statements is true regarding the BUFNO= option?",
      "explanation": "You can use the BUFNO= system option or data set option to control how many buffers are available for reading or writing a SAS data set. Using BUFNO= can improve execution time by limiting the number of input/output operations that are required for a particular SAS data set. However, the improvement in I/O comes at the cost of increased memory consumption. The number of buffers is not a permanent attribute of the data set and is valid only for the current step or SAS session.",
      "options": [
        {
          "tag": "A",
          "description": "A. The BUFNO= option specifies the size of each buffer that is used for reading or writing a SAS data set.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. The BUFNO= option can improve execution time by limiting the number of input/output operations that are required.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. Using the BUFNO= option results in permanent changes to the data set.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. Using the BUFNO= option to increase the number of buffers results in decreased memory consumption.",
          "correct": false
        }
      ]
    },
    {
      "number": "234",
      "description": "Which of the following statements is not true regarding a page?",
      "explanation": "A page is fixed in size when the data set is created, either to a default value or a specified value. You can use the BUFSIZE= option to control the page size of an output SAS data set. The new buffer size is permanent. After it is specified, it is used whenever the data set is processed.",
      "options": [
        {
          "tag": "A",
          "description": "A. A page is the unit of data transfer between the storage device and memory.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. A page includes the number of bytes that are used by the descriptor portion, the data values, and the overhead.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. The size of a page is analogous to buffer size.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. The size of a page can be changed at any time.",
          "correct": true
        }
      ]
    },
    {
      "number": "235",
      "description": "The total number of bytes occupied by a data set equals which of the following?",
      "explanation": "The total number of bytes occupied by a data set equals the page size multiplied by the number of pages. You can use the CONTENTS procedure to report the page size and the number of pages.",
      "options": [
        {
          "tag": "A",
          "description": "A. the page size multiplied by the number of pages.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. the page size multiplied by the number of observations.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. the sum of the page size and the number of pages.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. the number of pages multiplied by the number of variables.",
          "correct": false
        }
      ]
    },
    {
      "number": "236",
      "description": "Which statement opens the file Work.Quarter1, allocates enough buffers to hold the entire file in memory, and reads the data into memory?",
      "explanation": "The SASFILE LOAD statement opens the file, allocates the buffers, and reads the data into memory.",
      "options": [
        {
          "tag": "A",
          "description": "A. sasfile work.quarter1 open;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. sasfile work.quarter1 load;",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. sasfile work.quarter1 bufno=max;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. sasfile work.quarter1 bufsize=max;",
          "correct": false
        }
      ]
    },
    {
      "number": "237",
      "description": "Which of the following statements is true regarding a file that is opened with the SASFILE statement?",
      "explanation": "When a SAS data file is opened using the SASFILE statement, the data is held in memory, and is available to subsequent DATA and PROC steps or applications, until either a SASFILE CLOSE statement is executed or the SAS session ends. Though a file that is opened with the SASFILE statement can be used for subsequent input or update processing, it cannot be used for subsequent utility or output processing. If the file in-memory increases in size during processing, the number of buffers also increases.",
      "options": [
        {
          "tag": "A",
          "description": "A. The file is available to subsequent DATA and PROC steps or applications until a SASFILE CLOSE statement is executed or until the program ends.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. The file is available to subsequent DATA and PROC steps or applications until a SASFILE END statement is executed.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. The file is available for subsequent utility or output processing until the program ends.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. If the file increases in size during processing, the number of buffers remains the same.",
          "correct": false
        }
      ]
    },
    {
      "number": "238",
      "description": "Which of the following statements about uncompressed SAS data files is true?",
      "explanation": "The descriptor portion of an uncompressed data file is always stored at the end of the first data set page. New observations are always added to the end of the data set, and deleted observation space is neither tracked nor reused.",
      "options": [
        {
          "tag": "A",
          "description": "A. The descriptor portion is stored on whatever page has enough room for it.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. New observations are always added in the first sufficient available space.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. Deleted observation space is tracked.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. New observations are always added at the end of the data set.",
          "correct": true
        }
      ]
    },
    {
      "number": "239",
      "description": "Which of the following statements about compressed SAS data files is true?",
      "explanation": "The descriptor portion of a compressed data file is always stored at the end of the first data set page. If you specify REUSE=YES, SAS tracks and reuses deleted observation space within a compressed data file. Therefore, every observation in a compressed data file can be a different size. Compressed data files do have a larger overhead than uncompressed data files.",
      "options": [
        {
          "tag": "A",
          "description": "A. The descriptor portion is stored on whatever data set page has enough room for it.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. Deleted observation space can be reused.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. Compressed SAS data files have a smaller overhead than uncompressed SAS data files.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. In a compressed SAS data set, each observation must be the same size.",
          "correct": false
        }
      ]
    },
    {
      "number": "240",
      "description": "Which of the following programs correctly creates reduced-length numeric variables?",
      "explanation": "Use the LENGTH statement to assign a reduced length to a numeric variable. If you do not use the LENGTH statement to define a reduced length for numeric variables, their default length is 8 bytes. The FORMAT statement associates a format with a variable, and the INFORMAT statement associates an informat with a variable.",
      "options": [
        {
          "tag": "A",
          "description": "A. data temp;\ninfile file1;\ninput x 4.\ny 3.\nz 2.;\nrun;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. data temp;\nformat x 4.\ny 3.\nz 2.;\ninfile file1;\ninput x 4.\ny 3.\nz 2.;\nrun;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. data temp;\nlength x 4\ny 3\nz 2;\ninfile file1;\ninput x 4.\ny 3.\nz 2.;\nrun;",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. data temp;\ninformat x 4.\ny 3.\nz 2.;\ninfile file1;\ninput x 4.\ny 3.\nz 2.;\nrun;",
          "correct": false
        }
      ]
    },
    {
      "number": "241",
      "description": "Which of the following statements about SAS data views is true?",
      "explanation": "SAS data views use significantly less disk space than SAS data files. However, SAS data views might need more CPU resources than SAS data files. You can create a SAS data view in either the temporary SAS library or in a permanent SAS library.",
      "options": [
        {
          "tag": "A",
          "description": "A. SAS data views use less disk space but more CPU resources than SAS data files.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. SAS data views can be created only in permanent SAS libraries.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. SAS data views use less CPU resources but more disk space than SAS data files.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. SAS data views can be created only in temporary SAS libraries.",
          "correct": false
        }
      ]
    },
    {
      "number": "242",
      "description": "Which of the following programs should you use to detect any loss of precision between the default-length numeric variables in Company.Regular and the reduced-length numeric variables in the data set Company.Reduced?",
      "explanation": "Use the COMPARE procedure to detect any differences in the values of two data sets. The COMPARE statement is not valid syntax in either the CONTENTS procedure or the DATASETS procedure. Printing both data sets might not reveal differences in the precise values of the shortened variables, depending on the formats that are used.",
      "options": [
        {
          "tag": "A",
          "description": "A. proc contents data=company.regular;\ncompare data=company.reduced;\nrun;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. proc compare base=company.regular\ncompare=company.reduced;\nrun;",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. proc print data=company.regular;\nrun;\nproc print data=company.reduced;\nrun;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. proc datasets library=company;\ncontents data=regular compare=reduced;\nrun;",
          "correct": false
        }
      ]
    },
    {
      "number": "243",
      "description": "Placing the subsetting IF statement at the top rather than near the bottom of a DATA step results in a savings in CPU usage. What happens if the subset is large rather than small?",
      "explanation": "As SAS processes a larger subset of the data, more CPU resources are required. However, positioning of the subsetting IF statement in a DATA step can affect performance and efficiency.",
      "options": [
        {
          "tag": "A",
          "description": "A. The savings in CPU usage increases as the subset grows larger because the I/O increases.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. The savings in CPU usage decreases as the subset grows larger. However, placing the subsetting IF statement at the top of a DATA step always uses fewer resources than placing it at the bottom.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. The savings in CPU usage remains constant as the subset grows larger. However, placing the subsetting IF statement near the bottom of a data set is preferable.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. The savings in CPU usage decreases as the subset grows larger. However, placing the subsetting IF statement near the bottom of a data set increases the I/O.",
          "correct": false
        }
      ]
    },
    {
      "number": "244",
      "description": "Which of the following statements is true about techniques that are used for modifying data and attributes?",
      "explanation": "The DATA step is the only technique that can be used to modify both data values and variable attributes. The DATASETS procedure enables you to modify only variable attributes.",
      "options": [
        {
          "tag": "A",
          "description": "A. You can use PROC DATASETS to modify both data values and variable attributes.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. You can use PROC DATASETS to modify only data values.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. You can use the DATA step to modify both data values and variable attributes.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. You can use the DATA step to modify only variable attributes.",
          "correct": false
        }
      ]
    },
    {
      "number": "245",
      "description": "For selecting observations, is a subsetting IF statement or a WHERE statement more efficient? Why?",
      "explanation": "For selecting observations, a WHERE statement is more efficient than a subsetting IF statement because it examines what is in the input page buffer and selects observations before they are loaded into the program data vector, which results in a savings in CPU operations.",
      "options": [
        {
          "tag": "A",
          "description": "A. A subsetting IF statement is more efficient because it loads all observations sequentially into the program data vector.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. A subsetting IF statement is more efficient because it examines what is in the input buffer and selects observations before they are loaded into the program data vector, which results in a savings in CPU operations.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. A WHERE statement is more efficient because it loads all observations sequentially into the program data vector.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. A WHERE statement is more efficient because it examines what is in the input page buffer and selects observations before they are loaded into the program data vector, which results in a savings in CPU operations.",
          "correct": true
        }
      ]
    },
    {
      "number": "246",
      "description": "When is it more advantageous to create a temporary SAS data set rather than a permanent SAS data set?",
      "explanation": "It is more advantageous to create a temporary SAS data set rather than a permanent SAS data set when the external file on which the data set is based is frequently updated between SAS sessions.",
      "options": [
        {
          "tag": "A",
          "description": "A. When the external file on which the data set is based might change between SAS sessions.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. When the external file on which the data set is based does not change between SAS sessions.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. When the data set is needed for more than one SAS session.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. When you are converting raw numeric values to SAS data values.",
          "correct": false
        }
      ]
    },
    {
      "number": "247",
      "description": "When you compare the technique of using multiple DATASETS procedures to using a single DATASETS procedure to modify the descriptor portion of a data set, which is true?",
      "explanation": "A one-step DATASETS procedure results in a savings of CPU usage and I/O operations. PROC DATASETS supports RUN-group processing, which enables you to process multiple SAS data sets from the same library with one invocation of the procedure.",
      "options": [
        {
          "tag": "A",
          "description": "A. A one-step DATASETS procedure results in an increase in I/O operations.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. Multiple DATASETS procedures result in a decrease in I/O operations.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. A one-step DATASETS procedure results in a decrease in CPU usage.",
          "correct": true
        },
        {
          "tag": "D",
          "description": "D. Multiple DATASETS procedures result in a decrease in CPU usage.",
          "correct": false
        }
      ]
    },
    {
      "number": "248",
      "description": "Why can using an index reduce the number of I/O operations that are required for accessing a small subset?",
      "explanation": "When using an index to select a subset, SAS loads only the pages that contain at least one qualified observation into input buffers. When accessing observations sequentially, SAS must load all pages into input buffers. Loading more pages requires more I/O operations.",
      "options": [
        {
          "tag": "A",
          "description": "A. Using an index requires larger I/O memory buffers, which can hold more pages.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. The index does not have to be loaded into a memory buffer.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. The number of observations that SAS has to load into the program data vector (PDV) is decreased.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. The number of pages that SAS has to load into I/O buffers is decreased.",
          "correct": true
        }
      ]
    },
    {
      "number": "249",
      "description": "You want to select a subset of observations in the data set Company.Products, and you have defined a simple index on the variable Rating. SAS cannot use the index to process which of the following WHERE statements?",
      "explanation": "SAS does not use an index for a WHERE condition that contains a function other than TRIM or SUBSTR.",
      "options": [
        {
          "tag": "A",
          "description": "A. where rating is missing;",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. where rating=int(rating);",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. where rating between 3.5 and 7.5;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. where rating=5.5;",
          "correct": false
        }
      ]
    },
    {
      "number": "250",
      "description": "In which of the following situations is sequential access likely to be more efficient than direct access for WHERE processing?",
      "explanation": "The size of the subset relative to the size of the data set is an important factor in determining which access method is most efficient. If a subset is large (more than 33% of the data set), it is likely to be more efficient to use sequential access than direct access. Direct access is usually more efficient when you select a small subset (less than 33% of the data set), especially if the data set is large (has a high page count). However, if the data set is very small (less than three pages), using an index is not efficient. The number of key variables specified in a WHERE expression does not determine which access method is most efficient. If the two key variables that are specified are the first two variables in the same index, the WHERE expression is a candidate for compound optimization. Sorting the data also does not determine which access method is most efficient. However, sorting the data before subsetting improves the efficiency of WHERE processing regardless of the access method.",
      "options": [
        {
          "tag": "A",
          "description": "A. The subset contains more than 75% of the observations in the data set.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. The WHERE expression specifies both key variables in a single composite index.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. The data is sorted on the key variable.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. The data set is very large.",
          "correct": false
        }
      ]
    },
    {
      "number": "251",
      "description": "You want to summarize data and group it by one variable. Which of the following tools could not be used?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. The DATA step with BY-group processing.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. The DATA step without BY-group processing.",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. PROC SQL with a GROUP BY clause.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. PROC MEANS with a CLASS statement.",
          "correct": false
        }
      ]
    },
    {
      "number": "252",
      "description": "Which of the following techniques does not summarize data for specific combinations of class variables?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. the NWAY option in multiple PROC MEANS steps.",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. the TYPES statement in a PROC MEANS step.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. the WHERE= output data set option in a PROC MEANS step.",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. a basic PROC MEANS step.",
          "correct": true
        }
      ]
    },
    {
      "number": "253",
      "description": "Which of the following characteristics do not apply to subroutines?",
      "explanation": "Subroutine declares (creates) an independent computational block of code that you can call using a CALL statement so the parameters cannot be passed by value.",
      "options": [
        {
          "tag": "A",
          "description": "A. Parameters are passed by value.",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. The ENDSUB statement ends the definition of the subroutine.",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. can modify parameters",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. Do not return a value.",
          "correct": false
        }
      ]
    },
    {
      "number": "254",
      "description": "You can create one function and one CALL routine in a single FCMP procedure step.",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. True",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. False",
          "correct": true
        }
      ]
    },
    {
      "number": "255",
      "description": "Is OUTLIB= option required in PROC FCMP function?",
      "explanation": "OUTLIB specifies the three-level name of an output data set to which the compiled subroutines and functions are written when the PROC FCMP step ends.\nFollowing are syntax examples:\nproc fcmp outlib=sasuser.fcmpsubs.pkt1;\nproc fcmp outlib=sasuser.mysubs.math;",
      "options": [
        {
          "tag": "A",
          "description": "A. True",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. False",
          "correct": false
        }
      ]
    },
    {
      "number": "256",
      "description": "The OUTARGS statement is used with the FUNCTION and SUBROUTINE statements.",
      "explanation": "OUTARGS specifies arguments from the argument list that you want the subroutine to update.",
      "options": [
        {
          "tag": "A",
          "description": "A. True",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. False",
          "correct": true
        }
      ]
    },
    {
      "number": "257",
      "description": "The following SAS program is submitted:\n\n%let type = RANCH;\nproc sql;\ncreate view houses as\nselect *\nfrom sasuser.houses\nwhere style = \"&type\";\nquit;\n%let type = CONDO;\nproc print data = houses;\nrun;\n\nThe report that is produced displays observations whose value of STYLE are all equal to RANCH.\nWhich one of the following functions on the WHERE clause resolves the current value of the macro\nvariable TYPE?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. GET",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. SYMGET",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. %SYMGET",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. &RETRIEVE",
          "correct": false
        }
      ]
    },
    {
      "number": "258",
      "description": "The SAS data set SASDATA.SALES has a simple index on the variable DATE and a variable named REVENUE with no index.\nIn which one of the following SAS programs is the DATE index considered for use?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A.  proc print data = sasdata.sales;\n    by date;\n    run;",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B.  proc print data = sasdata.sales;\n    where month(date) = 3;\n    run;",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C.  data march;\n    set sasdata.sales;\n    if '01mar2002'd < date < '31mar2002'd;\n    run;",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D.  data march;\n    set sasdata.sales;\n    where date < '31mar2002'd or revenue > 50000;\n    run;",
          "correct": false
        }
      ]
    },
    {
      "number": "259",
      "description": "The following SAS program is submitted:\n\n%macro mysum(n);\n%if &n > 1 %then %eval(&n + %mysum(%eval(&n-1)));\n%else &n;\n%mend;\n%put %mysum(4);\n\nWhich output is written to the log?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. 10",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. 4+3+2+1",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. 7",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. A character operand was found in the %EVAL function or %IF condition where a numeric operand is required.",
          "correct": false
        }
      ]
    },
    {
      "number": "260",
      "description": "A local permanent data set has the following characteristics:\n1. 80 character variables, length 200, storing 28 bytes of non-repeating characters\n2. 120 numeric variables, length 8, 14 digits\n3. 4000 observations\n\nWhat is the best way to reduce the storage size of this data set?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. Compress the data set with character compression",
          "correct": true
        },
        {
          "tag": "B",
          "description": "B. Reduce length of character variables to 28 bytes",
          "correct": false
        },
        {
          "tag": "C",
          "description": "C. Compress the data set with binary compression",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. Reduce length of character variables to 6 bytes",
          "correct": false
        }
      ]
    },
    {
      "number": "261",
      "description": "The following program is submitted to check the variables Xa, Xb, and Xc in the SASUSER.LOOK data\nset:\n\ndata _null_ WORK.BAD_DATA / view=WORK.BAD_DATA ;\nset SASUSER.LOOK(keep=Xa Xb Xc);\nlength _Check_ $ 10 ;\nif Xa=. then _check_=trim(_Check_)!!\" Xa\" ;\nif Xb=. then _check_=trim(_Check_)!!\" Xb\" ;\nif Xc=. then _check_=trim(_Check_)!!\" Xc\" ;\nput Xa= Xb= Xc= _check_= ;\nrun;\n\nWhen is the PUT statement executed?",
      "explanation": "",
      "options": [
        {
          "tag": "A",
          "description": "A. when the code is submitted",
          "correct": false
        },
        {
          "tag": "B",
          "description": "B. only when the WORK.BAD_DATA view is used",
          "correct": true
        },
        {
          "tag": "C",
          "description": "C. both when the code is submitted and the view is used",
          "correct": false
        },
        {
          "tag": "D",
          "description": "D. never, the use of _null_ in a view is a syntax error",
          "correct": false
        }
      ]
    }
  ],
  "questionVersion": 4,
  "playStoreVersion": 10014,
  "ads": true,
  "categories": []
}